				SECCION 18 PROTECCION DE RUTAS,ROLES Y BUSCADOR

En esta sección tocaremos los siguientes temas:

1- Componente de búsqueda global
2- Menú del lado del servidor
3- AdminGuard - Un guard para verificar si es administrador
4- Recuperar información del TOKEN desde el front-end sin comunicación intermedia
5- Página 404
6- Manejo de errores

Al finalizar, su respectivo backup

						VIDEO 238 BUSQUEDA GLOBAL

En la navbar tenemos un icono de una lupa que despliega un input.Queremos realizar una busqueda de cualquier documento(ya tenemos el endpoint).Fijate que el input esta en el header.component.ts y que hace un hard refresh el form.¿Porqué?
Porque no tengo implementado ningun modulo de manejo de formularios.Fijate que esto es importante,en cuanto vea que un form hace refresh es porque tengo que importar algun modulo para forms.
NOTA:pudiera ser que tenga que bajar el ng serve para que tome efecto.

Para algo tan simple usamos el formModule y una ref local:
<form (submit)="buscar(txtTermino.value)">
 <input #txtTermino type...>

				VIDEO 239 COMPONENTE PARA BUSQUEDAS GLOBALES

Vamos a crear un componente que reciba el término introducido por la url y despues realize la busqueda.Obviamente primero hay que mandarlo asi que tras rescatarlo lo mando a una nueva url:
<form (submit)="buscar(txtTermino.value)">
<input #txtTermino ...>

buscar(termino:string){
  this.router.navigate(['/dashboar','busqueda',termino);
} 
Ya está mandado,ahora falta rescatarlo.La ruta será dinámica,con un param obligatorio:
path:'busqueda/:termino',component:BusquedaComponent <- creo ese componente
ng g c pages/busqueda --skip-test -is

Y para rescatarlo no necesito la clase Router sino la clase ActivatedRoute.Memoriza que no son las mismas clases,una para mandar y otra para recibir:

* En el BusquedaComponent,o el que vaya a recibir el :param hay que suscribirse al Observable this.activatedRoute.params(lo tengo también en this.activatedRoute.snapshot pero es estático y desde el mismo componente podría buscar y no lo vería desde la snapshot si no cambia la url):

constructor( private activatedRoute:ActivatedRoute){}
  ngOnInit(): void {
    this.activatedRoute.params .subscribe(params => { console.log(params.termino);
      });
  }
NOTA:también puedo usar navigateByUrl(`/dashboard/busqueda/${termino}` ó navigateByUrl("/dashboard/busqueda"+termino);

En cuanto a la pagina serán tres simples cards,una por colección,con una tabla sobre la que iteraremos.

				VIDEO 240 MOSTRAR LA INFORMACIÓN DE BUSQUEDA

Dado que ya tenemos el endpoint simplemente creo un servicio:
 busquedaGlobal(termino:string){
    const url = `${base_url}/todo/${termino}`;
    return this.http.get<any[]>(url, this.headers)
      .pipe(
        map<any, any>( (resp) => {
          const usuarios = this.transformarUsuarios(resp.usuarios);
          const hospitales = resp.hospitales;
          const medicos = resp.medicos;
          return { usuarios, hospitales, medicos } as any;
        })
      );
  };

Y lo llamo en ese Observable.Fijate que para no anidar dos Observables puedo sacar la logica a un método:
 ngOnInit(): void {
    this.activatedRoute.params.subscribe(params => {
      this.busquedaByTermino(params['termino']);
      });
  }


  busquedaByTermino(termino: string) {
    this.busquedasService.busquedaGlobal(termino)
    .subscribe( (resp) => {
      this.usuarios = resp.usuarios;
      this.medicos = resp.medicos;
      this.hospitales = resp.hospitales;
      });
  }

Fijate que tener una busqueda de este tipo da un aspecto muy profesional a la aplicación aparte de ayudar mucho al usuario a encontrar cualquier cosa.Implementar este tipo de busqueda global es fundamental.

				VIDEO 241 MENU DEL LADO DEL SERVIDOR

Fernando quiere retornar la composición del menú del lado del servidor.Cuando el usuario haga login puedo ver si es admin o un user normal y en base a eso retornar una estructura de menú u otra.
Si no es un administrador realmente no debería poder usar los mantenimientos,en esta aplicación realmente un usuario puede crear médicos y hospitales,tal como lo pensó Fernando,asi que un admin puede editar usuarios y un usuario menos esta opción puede acceder a todo:

export const getMenuOfFrontend = (role="USER_ROLE") =>{
  
  const menu = [
    { 
      titulo:'Dashboard',
      icono:'mdi mdi-gauge', 
      submenu:[
        {titulo:'Main', url:'/'},
        {titulo:'GraficaDona', url:'grafica-dona'},
        {titulo:'ProgressBar', url:'progress'},
        {titulo:'Promesas', url:'promesas'},
        {titulo:'Rxjs', url:'rxjs'},
      ]
    },
    {
      titulo:'Mantenimientos',
      icono:'mdi mdi-folder-lock-open',
      submenu:[
        // {titulo:'Usuarios', url:'usuarios'},
        {titulo:'Hospitales', url:'hospitales'},
        {titulo:'Medicos', url:'medicos'},
      ]
    }
  ]

  if(role==="ADMIN_ROLE"){
    menu[1].submenu.unshift({titulo:'Usuarios', url:'usuarios'})
  }
  return menu;
}

Ahora simplemente lo devuelvo en el register,en el login y en el renew,por si cambiara.Apenas es añadir una propiedad más con la llamada al método helper.:

* En cada respuesta lo mando
  res.json({
    ok: true,
    token,
    usuario:user,
    menu: getMenuOfFrontend(user.role),
  });
Como puedo ver no es nada dificil mandar un menu desde el backend y crear menus dinámicos en base al rol del usuario.

			VIDEO 242 CARGAR EL MENU DESDE EL SERVICE DEL FRONTEND

Realmente el menú no es información sensible,puedo incluso grabarlo en el localStorage.¿Dondé?Pues donde estaba guardando el token ahora guardo el menu también(fijate que es un arreglo luego hay que serializarlo):

* Mejor crear un pequeño método para no repetir las instrucciones.
  guardarLocalStorage(token:string,menu:[]) {
    localStorage.setItem('token', token);
    localStorage.setItem('menu', JSON.stringify(menu));
  }

IMPORTANTE: fijate como estabamos cargando una propiedad del servicio(y utilizando la capacidad de ser singleton un servicio de Angular):

export class SidebarService {
   public menu = [];

   cargarMenu() {
     this.menu = localStorage.getItem('menu') 
       ? JSON.parse(localStorage.getItem('menu')!) 
       : [];
      return this.menu;
   }
Yo no tengo porque usar un servicio SOLO PARA PETICIONES.Puedo devolver una propiedad cualquiera,en este caso devuelvo una propiedad menu,de donde lo cargue es indiferente,del localStorage,de un backend,...
Lo importante es que este servicio devuelve una propiedad.Ahora bien,¿cuando la cargo?.
Puedo seguir con la forma que tenia,iterando sobre el menu y cargandolo en el sidebar.component,claro que para cargarlo ahora tengo que llamar al método:
 public menuItems: any[] ;
  constructor(
    private sidebarService: SidebarService,
    private usuarioService: UsuarioService,
    ) { 
    this.menuItems = this.sidebarService.cargarMenu();
  }
Sin embargo,aqui viene lo importante,fijate que yo puedo declarar una propiedad en un servicio y despues distribuirla por la app simplemente con this.menuItems = this.sidebarService.menu(ahora es un método que devuelve la propiedad).

Sin embargo,Fernando sugiere llamar al método ya desde el pagesComponent(pues es una página con autenticación(con el canActivate).Me parece una buena idea.

En el pagesComponent...
  constructor(
    private settingsService: SettingsService,
    private sidebarService:SidebarService
    ) {} 

   ngOnInit(): void {
    this.sidebarService.cargarMenu();
    customInitFunctions();
  }

Fijate que llamar a this.sidebarService.cargarMenu() hace que pueda usar this.sidebarService.menu.Asi que si ya lo tengo cargado no necesito hacerlo en el sidebarComponent:
 <li *ngFor="let item of sidebarService.menu">

Obviamente tendré que añadir el servicio como público,ya que lo uso en la template.
NOTA:para que menu no me dé de tipo never[] lo debo declarar como menu:any=[] y no como menu=[];
También hay que purgar el menu en el logout:
  logout() {
    localStorage.removeItem('token');
    localStorage.removeItem('menu');
NOTA:fijate que un usuario normal no va a ver la opción del mantenimiento de usuarios más,pero AÚN PUEDE ACCEDER POR LA URL.Esto hay que controlarlo con un Guard.

					VIDEO 243 ADMIN GUARD

Fijate que ya tengo un guard que mira si el usuario está autenticado en cada ruta a través de un método que retorna un boleano:
 canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot) {
    
      return this.usuarioService.validarToken()
      .pipe( tap(estaAutenticado => {
        if (!estaAutenticado) {
          this.router.navigateByUrl('/login');
        }
      }));
  }
Esto es un guard,un simple boleano.Luego falta implemnentar en las rutas que quiera el guard que quiera.Asi que crearemos un guard que retorne true si el usuario es admin y false si es un usuario normal.
También voy al usuarioService y creo un getter para obtener el role:

  get role():'ADMIN_ROLE'|'USER_ROLE' {
    return this.usuario.role!;
  }
Aunque me hará cambiar la interfaz es mejor definir los posibles roles que pasar un string(o crearse una enum).

En el CanActivate escribo la lógica:
 if (this.usuarioService.role === 'ADMIN_ROLE') {
      return true;
    } else {
      console.log('Bloqueado por el admin guard');
      this.usuarioService.logout();
      return false;
    }
 
Ahora puedo implementar esta protección en la ruta o rutas que quiera:
{ path:'usuarios',
  canActivate:[AdminGuard],
  component: UsuariosComponent,
Debe ser un arreglo de Guards,aunque sea sólo uno.
Al final podemos hacer lo que queramos pero seguiré lo que hace Fernando y redireccionaré a simplemente /dashboard.

				VIDEO 244 VALIDAR EL ADMIN_ROLE EN EL BACKEND

Realmente ahora mismo cualquier usuario puede cambiarse el rol,esto no debería de poder realizarse.Solo un ADMIN puede cambiar los roles.Hagamoslo en el server.Realmente es bastante sencillo dado el orden de los middlewares:

const validarAdminRole = async (req= request, res = response, next)=> {
  const uid = req.uid;
  try {
    const usuario = await Usuario.findById(uid);  
    
    if(!usuario) {
      return res.status(401).json({
        ok: false,
        mensaje: "El usuario no existe",
      });
    }

Protegemos sólo el put:
router.put(
  "/:id",
  [
    validarToken,
    validarAdminRole,

Claro que ahora el usuario normal no puede actualizar su perfil.Falta especificar que si es el propio usuario puede actualizar su perfil(pero no su rol)

			VIDEO 245 VALIDAR SI ES EL MISMO USUARIO O UN ADMIN

 Falta validar que sea el mismo usuario.Hay que cambiar un poco el middleware:
  if (usuario.role === "ADMIN_ROLE" || usuario.id === id) {
     next()}else{
       return res.status(401).json({
         ok: false,
         mensaje: "No tiene permisos para realizar esta acción",
       });
     }
}

			SECCION 19 OPTIMIZACIONES-LAZY LOAD Y DESPLIEGUE

Esta sección esta orientada a realizar optimizaciones en nuestra aplicación y back-end:

1- Lazyload
2- Función para renovar el token
3- Guard de renovación de token
4- Leer el token localmente sin comunicación con el servidor
5- Optimizar el tiempo de renovación de token
6- Resolver problema con las imágenes mal ubicadas en la versión de distribución
7- Crear la versión de distribución

Al finalizar, el respectivo backup en Git y GitHub, pero adicionalmente tendremos el código fuente final del AdminPro y el Back-end Server

						VIDEO 250 LAZYLOAD

La carga perezosa se usa mucho.Ionic lo hace continuamente.Yo puedo usar lazy load cuando tengo muchos módulos,y quiero que sean cargados bajo demanda(y no todos desde un principio).
Esto es muy eficiente,además los cacheará y sólo se cargarán una vez,y bajo demanda.
Vamos a necesitar un nuevo modulo para esto:
ng g m pages/childRoutes --flat

NOTA:para implementar una carga perezosa siempre es con la propiedad 
loadChildren: () =>
Y es una funcion la cual usará la keyword import(ruta).then(clase):

 loadChildren: () => import('./child-routes.module').then(m => m.ChildRoutesModule)
Importará bajo demanda desde esa ruta esa clase/modulo que debe ser un modulo con rutas,claro.
Y esa clase/módulo que estoy importando bajo demanda tendrá que hacer uso del RouterModule:
@NgModule({
  imports: [ RouterModule.forChild(routes) ],
  exports: [ RouterModule ]
})
export class ChildRoutesModule { } importará hacia si mismo las rutas y despues las ofrece al resto.Esto es asi por motivos obvios.
Con lo que he hecho deberia cargarse el login y register la primera vez y cargarse tras el login este childRoutes.Lo puedo ver en Networking

			VIDEO 251 DESPLEGAR BACK+FRONT A UN SERVIDOR

Puedo usar varios hostings como Heroku o Vercel para desplegar mi APP.Dado que tengo un backend de Node no puedo usar GitHubPages o Netlify.
Usaremos Heroku.AL desplegar una app NOde en Heroku debo configurar el script 'start'.Dado que ellos no tienen nodemon en su server arrancaré con node index.js:

  "scripts": {
    "dev": "nodemon index.js",
    "start": "node index.js"
  },
Ahora hay que iniciar un repo con git init y settear el remoto:
 heroku git:remote -a hospitals-admin-angular-app <- el nombre cambiará
Una vez fijado su remoto a mi repo local ya puedo añadir,commitear,pushear,...:
git add . <- por si lo necesito,si hago cambios,etc ,puedo hacer lo que quiera en ese remoto
git commit -m "..."<- lo mismo
git push heroku master <- puedo hacer los re-deploys que necesite

Bien.Al final tendré mi backend en https://hospitals-admin-angular-app.herokuapp.com/
Fijate que inicié un repo dentro de otro repo,perfecto fakin git que bueno es

				VIDEO 252 GENERAR EL BUILD DE ANGULAR

Antes de hacer el build de Angular tengo un problema en el backend.Esto es porque estoy subiendo imagenes a mi server,y éste cambia.
Heroku cada 24 horas hace un barrido de mi aplicación y lo resetea al código inicial,con lo que borrará las imágenes.
Podría usar Cloudinary por ejemplo.

Antes de hacer el build tengo que ir a los environments de produccion y cambiar la url:
export const environment = {
  production: true,
  base_url: 'https://hospitals-admin-angular-app.herokuapp.com/api' 
};
Ya puedo hacer el ng build.Cuando termine copio su contenido a la carpeta public del backend.
Sin embargo aún me queda decirle al backend cuando debe ser su router el que tenga el control y cuando el de Angular:

			VIDEO 253 BACKEND SERVIR UNA SPA - USAR DOS ROUTERS

Lógicamente,las rutas del frontend no son conocidas por el backend,asi que cuando
 refresque y tome el control express no podrá encontrar la ruta y dará error cannot GET /...

Lo mejor es pasarle una wildcard para ceder el control al enrutador del framework
app.get('*', (req,res)=> {
    res.sendFile(path.join(__dirname,'public/index.html'))
});
NOTA: hay que agregar el nuevo dominio al proyecto de Google!

Por último,debo subir a GitHub todo,ya que tanto el server como el front están listos para producción.

						SECCION 20 INTERCEPTORS

En esta sección tocaremos varios temas como:

1- Interceptores
2- Operadores de RXJS como map, catchError
3- Objetos propios de RXJS como el throwError
4- Explicaremos el por qué de los interceptores y cómo usarlos

Y otras cosas... pero el objetivo principal es aprender a implementarlos, ver su uso y los beneficios que nos brindan.

Esta es una sección añadida después de haber terminado el curso, es un bonus al mismo porque muchos alumnos me lo han pedido.

Con esto en mente creo un proyecto nuevo.En él veremos como realizar peticiones http e interceptarlas en Angular(usando rxjs,al parecer).

			VIDEO 258 PETICIONES HTTP DE FORMA TRADICIONAL-HttpParams-HttpHeaders

Antes de nada recuerda que para poder usar peticiones http tengo que importar el HttpClientModule:
import { HttpClientModule } from '@angular/common/http';

Luego solo es usar el servicio inyectandolo.Pero fijate que si quiero mandar parámetros opcionales como page o per_page puedo usar la clase HttpParams() que crea los params y con el método append(name,value) agregarlos.
Claro que también puedo crear un template string:

* En el service:
 constructor(private http:HttpClient){}

  getUsuarios(){
  let params = new HttpParams().append('page',2);
  return this.http.get(url,{params});

* Dado que es común agregar nuevos queryParams es mejor usar 'let'.Si quisiera agregar headers puedo usar la clase HttpHeaders(fijate que siempre es Httpxxx):
const headers = new HttpHeaders({'x-token':'sjffkd'})
return this.http.get(url,{params,headers}) <- y van como otra propiedad más en el segundo argumento opcional options?.

Sin embargo imagina que tengo muchas peticiones con headers y params diferentes.Esto no es del todo reusable(aunque en la gran mayoria de los casos es suficiente)

		VIDEO 259 OPERATORS RXJS MAP-THROW ERROR Y CATCH ERROR

Perfectamente puedo usar operadores rx para transformar la respuesta,como el map:

  return this.http.get(`${this.req_api}`,
     { headers,params }).pipe(
      map( (resp:any) => resp['data'])
     );

Sin embargo puedo apreciar que si pongo la url mal no estoy capturando el error(es decir,no estoy tratando el error de la manera que yo quiera)

El operador catchError se encarga de atrapar el error,tal como su nombre indica y me permite devolver mi propio error,incluso puedo enviar lo que quiera como respuesta.
El operador throwError crea un Observable que no emite nada al observer y automáticamente emite una notificación de error.Usaremos este Observable para el retorno del catchError.

this.http.get(url,{params,headers}).pipe(
  map( (resp:any) => resp['data']J),
  catchError( err => {
    console.warn('Error en la petición!');
    return throwError('Error de tipo:',err);
})

Pero de nuevo imagina que por cada petición tengo que ir repitiendo esto.Una solución podría ser crear un función,cierto:
manejaError(error:HttpErrorResponse){
  code for handling an Error
}

Aqui es donde veo la necesidad de implementar algo que me pueda ayudar a intercepar todas las peticiones fallidas de mi app y procesarlas sin repetir código.
En aplicaciones con muchas peticiones interceptar las peticiones es crucial para no repetir código.Los interceptores además no son sólo para el manejo de errores sino también para insertar el token en el header de cada petición o usar un param...

				VIDEO 260 INTERCEPTORES

Los interceptores no son más que un servicio común y corriente:

ng g s interceptors/interceptor --skip-tests

Recuerda que un servicio es una simple clase,asi que para que sea un interceptor tendrá que implementar la interfaz HttpInterceptor y desarrollar su método abstracto intercept(req,next):Observable

/* Para usar un interceptor tengo que implementar la interface HttpInterceptor y desarrollar su método intercept */
@Injectable({ providedIn: 'root' })
export class InterceptorService implements HttpInterceptor{

  /** el método intercept tiene como primer argumento la request que es de tipo HttpRequest<any>(pues puede ser cualquiera).
   * Como segundo arg lleva el next de tipo HttpHandler.
   * El método retornará un Observable que resuelve cualquier cosa también.
   * Un interceptor es como una válvula abierta,que recibe la request y debe retornarla.Lo mismo que recibe lo retorna.
   * Para ello se usa el método next.handle(req) que es el que recibe la request y retorna un Observable.
   * No puedo retornar una request,debe ser un Observable.
   * 
   *  */
  
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    console.log('paso por el interceptor');
    return next.handle(req);;  
  }

Sin embargo esto no es suficiente,no veré este console.log.Tengo que avisar a Angular(en los providers) que he creado un interceptor.Lo haremos en el app.module,en un objeto dentro del arreglo 'providers':
 providers: [{
    provide: HTTP_INTERCEPTORS,
    useClass: InterceptorService,
    multi: true
  }],

Ojo,que hay que importar ambos.Y hay que usar multi:true para que escuche por todas las peticiones:

import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import { InterceptorService } from './interceptors/interceptor.service';

Claro que nuestro interceptor que retorna next.handle(req); no hace nada aún.

NOTA.al parecer los interceptors siempre van en el providers del app.module y tendré que usar una condición para que no actue el interceptor en el login y register,si por ejemplo estoy mandando un token,porque intercepta todas.

			VIDEO 261 CONFIGURAR EL INTERCEPTOR

Realmente es bastante obvio lo que hay que hacer.Dado que recibo la request en el interceptor tendré que agregarla lo que quiera.

Sin embargo tengo que tener en cuenta una cosa.La request ya ha sido lanzada y no puede ser manipulada,no es mutable.Luego hay que clonarla.Y además hay que clonarla antes de manipularla,claro.Es decir que lo primero obligatoriamente es  clonar la request.Para ello está el método de instancia clone():
   
 const headers = new HttpHeaders({
    'token-usuario':'abcdefghijklmnopqrstuvwxyz'
  });
 const params = new HttpParams().append('page',2);

   /* la request en este punto ya ha sido lanzada y una request no puede manipularse una vez ha sido lanzada.Debo clonar la request y despues manipularla,en este orden */
    const reqClone = req.clone({
      headers,
      params
    });
    
    return next.handle(reqClone);  
  }
Desde ahora todas las peticiones llevarán estos headers y estos params.Y fijate que limpio queda el servicio:
return this.http.get(`${this.req_api}`).pipe(
        map( (resp:any) => resp['data']));

Uno de los objetivos de crear un interceptor es configurar un registro de todos los errores(puedo interceptarlos y mandarlos a una DB),otro objetivo es simplemente manejar el error de la manera en particular que desee como desarrollador.Hagamoslo:

Dado que intercept(req,next):Observable devuelve un Observable es bien fácil:

return next.handle(reqClone).pipe( catchError(handleError) );
 
  handleError(error: HttpErrorResponse) {
    console.log('Error en la petición');
    console.warn('Guardando en el log de errores...');
    return throwError('Error de tipo:'+error);
  }

Ahora podría guardar cada error en una petición en un registro en una DB,por ejemplo.Desde luego parece algo muy bueno.Seguir investigando y mejorando con interceptores(implementarlos también a modo de aprendizaje).

			SECCION 21 PRUEBAS AUTOMÁTICAS-UNITARIAS-INTEGRACIÓN

Esta es una sección pequeña introductoria al tema de las pruebas de integración y unitarias. Hay dos clases explicativas para comprender un poco más sobre las pruebas.

Esta parte del curso, parte de cero, ya que anteriormente no he cubierto este tema, por lo que si eres experto en esto, posiblemente valga la pena saltarse la siguiente sección y comenzar con las pruebas unitarias intermedias/avanzadas.

Las pruebas están ubicadas en 4 categorías:

1- Básicas - realmente son las pruebas más simples que nos ayudarán a iniciar
2- Intermedias - Son pruebas con una pequeña dificultad
3- Intermedias 2 - Son pruebas con un poco más de complejidad
4- Avanzadas - Son pruebas que ya usan diversos servicios y construcción personalizada para usar servicios falsos controlados por nosotros

		VIDEO 265 TEORÍA PRUEBAS AUTOMÁTICAS-TESTING

A la hora de hablar de pruebas suelen surgir cuatro preguntas:
1- ¿Para qué sirven?
2- ¿Qué debo de probar?
3- ¿Valen la pena?
4- ¿Qué tipos de pruebas existen?

Las pruebas sirven para probar cualquier funcionalidad de mi aplicación,pero sin tener que realizar posibles pasos adicionales,como haberse logeado.Ejecutan un test en un ambiente controlado,simulando cualquier paso necesario anterior.

VENTAJAS
Las pruebas ayudan a encontrar errores y permite probar código de otros programadores.
Permiten detectar errores antes de desplegar la aplicación a producción.
Ayudan a generar un código más limpio,generando reportes y estadísticas útiles.

DESVENTAJAS
Probar todo el código lleva mucho tiempo.
No garantizan un código 100% libre de errores.
Los costos aumentan

¿QUÉ DEBO DE PROBAR?
Hay que probar todo,sin embargo,esto es muy difícil por no decir imposible.Lo mejor es siempre quedarse en un punto intermedio entre probar todo y no probar nada,es decir probar un 50% de la aplicación(siempre priorizando puntos críticos).
Sobre todo hay que probar el corazón de la app,lo más importante que haga esa app

Por último recalcar que hay dos tipos de pruebas,automáticas y manuales.Las manuales ya las llevo a cabo yo como desarrollador.
Consisten en ir a editor,escribir código,ir al navegador,ver que falla,etc.Es algo que ya hará el desarrollador en su día a día.

				VIDEO 266 TIPOS DE PRUEBAS

Las pruebas automáticas se dividen en tres partes:

1- Unitarias: permiten tomar un pedazo de código y probarlo de forma aislada.No tendrán presencia de recursos externos,como llamadas a una API u otro servicio.
Normalmente tendré que hacer un mock de ese servicio,ya que por ejemplo no podré logearme sin hacer un llamado.Pero será un petición fake.
Permiten probar rápidamente cualquier función o método.
Puedo escribir muchas en poco tiempo
Puedo hacer pruebas de estrés  
Pero no podré saber los tiempos de respuesta de la API ya que opero sobre un fake

2- De Integración: aquí ya influyen dos o más componentes(por ejemplo una función que modifica el html ya está actuando sobre dos componentes)
De nuevo mockearán cualquier data que necesiten.
Aún con estos dos tipos al entrar un usuario en la app final podría haber fallos,es por eso que todavía quedará testear la app final con las endToEnd.

3- EndToEnd:También conocidas como de extremo a extremo.Son pruebas muy lentas,ya que se testea en la propia app,y esto es muy lento(tener que logearse,etc).
Por lo general se recomienda no usar EndToEnd y ser muy precisos en las unitarias y de integración para asi evitar estas últimas que son muy lentas
Las pruebas EndToEnd evaluan un flujo completo de la app.Normalmente las realiza QA sobre una versión beta 
 Las pruebas EndToEnd se realizan en un entorno de aplicación completo con un comportamiento mas realista.

				VIDEO 267 INICIO DEL PROYECTO DE PRUEBAS

Vamos a crear un proyecto nuevo.Para probar un proyecto Angular es con ng test.
Esto va a levantar un pequeño navegador web.Angular CLI ya viene con jasmine,que es un framework para pruebas.Viene ya configurado además.

Puedo ver que es muy parecido a jest:
describe('AppComponent', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [
        AppComponent
      ],
    }).compileComponents();
  });

  it('should create the app', () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

En cuanto a la nomenclatura hay que usar la misma de siempre file.spec.extension,la extension será ts por motivos obvios.
Jasmine buscará todos los archivos .spec.ts.
Si quisiera ignorar una prueba(o todas) tengo que poner una x delante:


xdescribe('AppComponent', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [
        AppComponent
      ],
    }).compileComponents();
  });

Puedo ver que las omitirá(skipped 3):
✔ Browser application bundle generation complete.
Chrome 96.0.4664.110 (Linux x86_64): Executed 0 of 3 (skipped 3) SUCCESS (0.009 secs / 0 secs)
TOTAL: 0 SUCCESS

				SECCION 22 PRUEBAS UNITARIAS BÁSICAS

Esta sección es muy básica.Paulatinamente iremos subiendo en dificultad.
Sección dedicada a las pruebas unitarias propiamente, son pruebas muy básicas, por lo que si eres conocedor del tema, las sentirás aburridas.

1- Probaremos Strings
2- Números
3- Booleanos
4- Arreglos
5- Clases
6- Cobertura de nuestras pruebas.

La cobertura sobre las pruebas, nos ayudará a saber que tantas líneas de nuestro código están cubiertas y respaldadas por pruebas unitarias

				VIDEO 270 GENERALIDADES DE LAS PRUEBAS

Normalmente en Angular los archivos de pruebas se encuentran al lado del archivo a testear,dada su naturaleza.De nuevo,jasmine barrerá el proyecto en busca de .spec.ts files,asi que esto no es muy importante.

Un archivo de pruebas siempre empiezan con el método describe(),que englobará a todas las pruebas.Cada prueba usará el método it(),de forma similar a test() en React:

describe('Pruebas en el string.ts', () => {
  
  it('Debe de regresar un string', () => {
    
  })
})
NOTA.puedo entrar al modo DEBUG en el navegador de las pruebas y abrir las devtools de ese navegador para ver los console.log.

					VIDEO 271 PROBANDO STRINGS

NOTA: En Angular para poder testear algo voy a tener que exportarlo.Veamos como testear esta simple función:
 
export function mensaje (nombre: string) {
  return `Hola ${nombre}`;
}

Fijate que tengo autocompletado 
 it('Debe de regresar un string', () => {
    const resp = mensaje('Juan');
    expect(typeof resp).toBe('string');
  })

			VIDEO 272 COMPROBAR QUE EL RESULTADO CONTENGA ALGO

Realmente comprobar sólo el tipo no es una gran prueba.Sería mejor poder comprobar que el contenido de la repuesta al método sea algo concreto:

  it('Debe de regresar un string con el nombre enviado', () => {
    const resp = mensaje('Juan');
    expect(resp).toContain('Juan');
  });
  
Fijate que también puedo usar toBe.Sin embargo,es mucho mejor evaluar con ToContain ya que  con el ToBe si agregara un simple espacio mal o de más en el método daría fallo.Es mejor idea usar ToContain.ToBe es cuando quiera tener certeza absoluta.

					VIDEO 273 PROBANDO NUMEROS

Evaluemos algo tan fácil como esto:
export function incrementar(n: number) {
  if(n>100) {
    return 100;
  }
  return n + 1;
}
Realmente no hay complicación alguna:
describe('Pruebas en numeros.ts', () => {
    it('Debe de retornar 100, si el numero ingresado es mayor a 100', () => {
      const numero = 101;
      const resp = incrementar(numero);
      expect(resp).toBe(100);
    });

    it('Debe de retornar el numero ingresado mas 1, si el numero ingresado es menor a 100', () => {
      const numero = 50;
      const resp = incrementar(numero);
      expect(resp).toBe(51);
    });

					VIDEO 274 PROBANDO BOOLEANS

Analizemos:
export function usuarioLogeado(){
  return true;
}
Poco que decir,solo que puedo usar ToBeTruthy() o ToBeFalsy() también
describe('Pruebas de booleanos', () => {
  it('Debe de retornar true', () => {
    const resp = usuarioLogeado();
    expect(resp).toBe(true);
    expect(resp).toBeTruthy();
    expect(resp).not.toBeFalsy();
  })

NOTA:Segun veo, han añadido nuevas métodos en el jasmine 3.5.0, las cuales se llaman directamente toBeTrue() y toBeFalse(), las cuales son mucho mas confiables que las toBeTruthy() y toBeFalsy(), porque la estructura de las nuevas es mucho mas estricta y firme que esas, y por lo que veo, si se van a evaluar booleanos, es recomendable usar entre toBe(true|false) o toBeTrue().
Usar nuevas funciones.

					VIDEO 275 PROBANDO ARREGLOS

Evaluando esta función:
export function obtenerRobots(){
  return ['Megaman', 'Jarvis', 'Robocop', 'R2D2'];
}
Puedo testear por ejemplo que siempre tenga al menos tres robots:

  it('Debe de retornar al menos 4 robots', () => {
    const robots = obtenerRobots();
    expect(robots.length).toBeGreaterThanOrEqual(4);
  });

De nuevo no es buena idea poner toBe(3) por ser muy rigido.La función ToContain() es igual de útil con arreglos:
  it('Debe de contener a Megaman y a Jarvis', () => {
    const robots = obtenerRobots();
    expect(robots).toContain('Megaman');
    expect(robots).toContain('Jarvis');
  });
Es una función básica,como puedo observar.

							VIDEO 276 PROBANDO CLASES 

NOTA:este video es muy importante,ya que en Angular todo son clases.
Evaluemos esta clase:
export class Jugador {
  hp:number;
  
  constructor() {
    this.hp = 100;
  }
*No queremos tener vida negativa
  recibirDanio(danio:number) {
    if(danio >= this.hp) {
      this.hp = 0;
    } else {
    this.hp = this.hp - danio;
    }
    return this.hp;
  }
}

  it('Debe de retornar 0 de hp,si recibe mas de 100 de daño', () => {
    const jugador = new Jugador();
    jugador.recibirDanio(150);
    expect(jugador.hp).toBe(0);
  });
Recuerda que las pruebas son secuenciales y transmiten sus valores.Si tuviera esta linea fuera de cada prueba el resultado no sería el mismo:
const jugador = new Jugador();
Aqui entra en juego los ciclos de vida de las pruebas(beforeAll,beforeEach,afterEach y afterAll),que veré en el siguiente video.

				VIDEO 277 CICLOS DE VIDA DE LAS PRUEBAS


