			SECCION 14 IMPLEMENTAR EL LOGIN Y REGISTRO EN EL FRONTEND

Esta sección tiene por objetivo implementar la seguridad de nuestra aplicación:

1- Conectar el Front-end con el Back-end (login)
2- Usar Sweet Alert para mostrar mensajes
3- Login normal de usuario
4- Login de Google
5- LocalStorage para almacenar tokens
6- Protección básica de rutas
7- Logout

Al finalizar, tendremos los respectivos commits en nuestro repositorio local y en GitHub.

					VIDEO 162 CREANDO UN MODELO DE USUARIO

En el proyecto de Angular tengo que crear los modelos de los objetos con los que trabajaré.Empecemos con el Usuario.Será una clase porque es más funcional que una interface:
export class Usuario{
  constructor(
    public nombre: string,
    public email: string,
    public password?: string,
    public img?: string,
    public google?: boolean,
    public role?: string,
    public uid?: string,
  ){}
}
Las propiedades opcionales van al final.Usamos la forma corta.Fijate que una interfaz daría el tipado pero poco más.Con una clase puedo heredar e inicializar cualquier propiedad a un valor al crear la instancia.

			VIDEO 163 FORMULARIO DE REGISTRO-REACTIVE FORMS

Tenemos que trabajar con el formulario del LoginComponent.Usaremos formularios reactivos.
Antes que nada recuerda que en Angular hay que cambiar el atributo href por routerLink para usar el enrutador del framework:
*En Angular tampoco se usa href,igual que en React
<a routerLink="/register" 
Lo mismo para ir al login desde el registerComponent
<a routerLink="/login"

Vamos a trabajar con formularios reactivos así que en el módulo donde estén los componentes para la auth lo requiero 

NOTA:fijate que cuando inyecto una clase  en Angular se supone que es un error de sintaxis y no da autocompletado:

public registerForm = this.fb.group({ <- no veo a group()
    firstName: [''],
  }) 
  
constructor(private fb: FormBuilder) { }

Con todo lo anterior en mente enlazo clase y formulario:
 public registerForm = this.fb.group({
    nombre: ['Oscar',[Validators.required, Validators.minLength(2)]],
    email: ['test01@test.com',[Validators.required, Validators.email]],
    password: ['123456',[Validators.required, Validators.minLength(6)]],
    password2: ['123456',[Validators.required, Validators.minLength(6)]],
    terminos: [false, Validators.required],
  }) 

En la template hay que enlazar esta instancia:
  (ngSubmit)="crearUsuario()"
   autoComplete="off"
  [formGroup]="registerForm"

Aparte de ir por cada campo:
    <input
      id="checkbox-signup" 
      type="checkbox"
      formControlName="terminos"
   >

				VIDEO 164 VALIDACIONES GENERALES

 Vamos a crear algo sencillo.Con un ngIf mostramos un simple <p> con el error para cada campo:
   <div class="row">
     <div class="col text-danger">
        <p *ngIf="campoNoValido('nombre')">El nombre es obligatorio</p>
        <p *ngIf="campoNoValido('email')">El email es obligatorio</p>
        <p *ngIf="registerForm.get('terminos')!.value">Debe de aceptar los términos de uso</p>
      </div>
  </div>

Al final cambiamos ese registerForm.get('terminos')!.value
  aceptaTerminos(): boolean{
    return this.registerForm.get('terminos')!.value && this.formSubmitted;
  }
REcuerda que hay varias formas de acceder a controles de formulario.

					VIDEO 165 VALIDAR CONTRASEÑAS 

Fijate que hemos usado dos contraseñas.Deberían ser iguales,y esto lo podemos validar ya antes de mandar el formulario.

NOTA: fijate que debo esperar siempre a que se postee el formulario para mostrar los errores:
  contrasenasNoCoinciden(): boolean{
    const pass1 = this.registerForm.get('password')!.value;
    const pass2 = this.registerForm.get('password2')!.value;
    return (pass1 != pass2) && this.formSubmitted;
  }
  
Sin embargo,debo tener en cuenta que este método no va a cambiar la validez del formulario(el form.valid seguirá siendo true).
Asi que si realmente quiero que una funcionalidad mía cambie el valid | invalid de un form debo crear una función validadora:

   ...  
  terminos: [false, Validators.required],
  },{
    /* como segundo argumento puedo pasar validadores mios con la propiedad validators,que cambiarán el estado del formulario,ojo */
    validators: this.passwordsIguales('password', 'password2')
  }) 
Esto se hace en un segundo argumento que es un object con opciones.Hay que pasarle una funcion validadora custom:

/* impl de la funcion validadora.Debe ser una funcion que retorne otra funcion,la cual será ejecutada */
passwordsIguales(pass1: string, pass2: string){
    return (formGroup: FormGroup) => {
      /* son los controles enteros */
      const pass1Control = formGroup.get(pass1);
      const pass2Control = formGroup.get(pass2);
      if(pass1Control!.value === pass2Control!.value){
        // puedo retornar el error en cualquier campo del formulario
        pass2Control!.setErrors(null);
      }else{
        pass2Control!.setErrors({noCoincide: true});
      }
    }
  }

Este tipo de funciones tienen que setear los errores del form o a true o a null para cuando pase.Realmente es bastante sencillo todo.

			VIDEO 167 USUARIOSERVICE - CREAR USUARIOS

Fijate que es un buen momento para tipar el formulario con una interfaz:
export interface RegisterForm {
  nombre: string;
  email: string;
  password: string;
  password2: string;
  terminos: boolean;
}
  
REcuerda que nada debería ir sin tipo en TS.El servicio a crear es sencillo

  crearUsuario(formData:RegisterForm){
    return this.http.post(`${base_url}/usuarios`, formData);
  }

NOTA: fijate que hemos usado una interfaz porque no necesito un modelo/clase ya que no necesito sus ventajas, con el tipado me vale,y asi no compilo a nada con la interfaz,con una clase ocuparé bytes.

En cuanto a la subscription parece que pide un observer desde Angular 12:
  this.usuarioService.crearUsuario(this.registerForm.value)
      .subscribe({
        next: (response) => {
          console.log(response);
        },
        error: (err) => {
          console.log(err);
          Swal.fire('Error', err.error.msg, 'error');
        }, 
        complete: () => {
          console.log('Usuario creado satisfactoriamente!');
        }
      })
  }

						VIDEO 169 LOGIN

Recuerda que para enlazar una clase con un formulario necesito la etiqueta [formGroup]="instancia",en este caso usaré [formGroup]="loginForm".
Despues cada campo usará un [formGroupName] que sustituye al name y se enlaza con cada propiedad de esa instancia.
Adicionalmente también necesitaré una función en el (ngSubmit),así que son dos cosas.

* El form es muy sencillo
  public loginForm = this.fb.group({
    email: ['test@test.com', [Validators.required, Validators.email, Validators.pattern('[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,3}$')]],
    password: ['', [Validators.required, Validators.minLength(6)]],
    remember: [false, ],
  });
  
Me creo su interface para el tipado(de nuevo recuerda que aparte que hay que tipar todo realmente no me importa definir x interfaces,no van a compilar a nada)

  login(){ 
    this.usuarioService.login(this.loginForm.value)
    .subscribe({
      next: (res) => {
        console.log(res);
      },
      error: (err) => {
        Swal.fire('Error', err.error.msg, 'error');
      },
      complete: () => {
        this.formSubmitted = false;
        this.router.navigate(['/']);
        // window.open( '/dashboard', '_self' );
      }
    });
  }
Creo el servicio y lo llamo,etc...
NOTA:puedo usar ngModel cuando voy a usar un formulario simple,usando simplemente ngModel en cada campo,pero en cuanto quiera usar validaciones,restricciones y el formulario sea un poco complejo debo usar esta aproximación con formularios reactivos.

				VIDEO 170 GUARDAR INFORMACIÓN EN EL LOCALSTORAGE

El localStorage es un lugar persistente,pero aún asi no es del todo fiable al 100%.Sin embargo,aún asi es el lugar ideal para guardar el token(que es una forma de guardar información del usuario).
También se puede usars la sessionStorage,sólo que cuando se cierre el browser esta información se borra.

Para realizar este paso lo puedo hacer con el operador 'tap'.El operador tap simplemente vale para realizar un efecto secundario,para adicionar un paso más a la lógica sin mutar nada.Es ideal para realizar esta función de guardado.

NOTA:fijate que en cuanto uso HttpClientModule estoy con Observables y que esto:
  login(formData:LoginForm):Observable<Object>{
    return this.http.post(`${base_url}/login`, formData);
  }
Es un Observable(al que luego me subscribiré,luego nada me impide mutar la respuesta o concatenarle un efecto o paso con tap:

 crearUsuario(formData:RegisterForm):Observable<Object>{
    return this.http.post(`${base_url}/usuarios`, formData)
    .pipe(
      tap( (resp:any) => {
        localStorage.setItem('token', resp.token);
      })
    );
  }
Y recuerda que no necesito darle el tipo de retorno,lo va a inferir TS si es declaración más asignación de la lógica.
IMPORTANTE:yo sólo puedo guardar strings en el localStorage,pero el token ya es un string,asi que no tengo que parsearlo.

					VIDEO 171 FUNCIONALIDAD DEL REMEMBER-ME

 Realmente es bastante sencillo,si el checkbox está activado es que quiere recordar el email,asi que lo guardo en el localStorage:

En un primer submit exitoso le guardo la contraseña

        if(this.loginForm.get('remember')!.value){
          localStorage.setItem('email', this.loginForm.get('email')!.value);
        }else{
          localStorage.removeItem('email');
        }

Despues el campo le asigno el valor si lo tiene guardado:
 email: [localStorage.getItem('email') || '',

Fijate que usando la misma estrategia puedo guardar aparte de su email,el rememberMe sobre el email(creo que tengo que hacerlo,si no lo limpio).

NOTA: Implementarlo en mi app. 

NOTA:al final hay que dar persistencia al checkbox también!:
      if(this.loginForm.get('remember')!.value){
          localStorage.setItem('email', this.loginForm.get('email')!.value);
          localStorage.setItem('remember', this.loginForm.get('remember')!.value);
        }else{
          localStorage.removeItem('email');
          localStorage.removeItem('remember');
        }

	VIDEO 173 OBTENER EL TOKEN DE AUTENTICACIÓN DE GOOGLE-SIGNIN-API

Si bien podría seguir con el botón de la aplicación vamos a usar el oficial:
https://developers.google.com/identity/sign-in/web/build-button

NOTA:tengo que copiar todo del ejemplo,incluso las etiquetas <meta>:
 <meta name="google-signin-client_id" content="YOUR_CLIENT_ID.apps.googleusercontent.com"> <-  tengo que copiar TODO
Aparte tendré que sustituir YOUR_CLIENT_ID por mi IDpúblico.

Y me pide otro script:
<script src="https://apis.google.com/js/platform.js?onload=renderButton" async defer></script>

Sin embargo ese ?onload me va a dar problemas(porqué??) asi que lo quito:
<script src="https://apis.google.com/js/platform.js" async defer></script>

IMPORTANTE: fijate que este script tiene toda la pinta que me va a dar acceso a la variable global 'gapi' de los siguientess scripts.En un simple index.html tendría acceso a él,pero desde un framework como Angular o React necesito pasar esa variable al framework,se hace simplemente declarandola:

declare const gapi:any; <- el framework la va a buscar en los scripts del index.html donde está embebido el <div id="root">

 onSuccess(googleUser:any) {
    console.log('Logged in as: ' + googleUser.getBasicProfile().getName());
  }

  onFailure(error:any) {
    console.log(error);
  }

  renderButton() {
    gapi.signin2.render('my-signin2', {
      'scope': 'profile email',
      'width': 240,
      'height': 50,
      'longtitle': true,
      'theme': 'dark',
      'onsuccess': this.onSuccess,
      'onfailure': this.onFailure
    });
  }

Por último este div pintará el botón:
   <!-- boton Oficial Google -->
   <div id="my-signin2"></div>

Fijate que el script que ellos me proporcionaban no me asegura que el componente LoginComponent se haya cargado tanto su HTML como su DOM y ya esta llamando a la función renderButton.Esto debo corregirlo,valdría para un index.html con su js,pero no para un framework:
  <script src="https://apis.google.com/js/platform.js?onload=renderButton" async defer></script>

EL onInit si me asegura que ejecuta algo DESPUES DE QUE SE HAYA CARGADO EL COMPONENTE(de echo inmediatamente despues)

 ngOnInit(): void {
    this.renderButton();
  }
Perfecto.Fijate que useEffect y useLayoutEffect son su contrapartida en React.

Fijate que ha sido muy sencillo,importante entender como puedo pasar variables globales de un script al framework.

Por último,tengo que agregar localhost:4200 a los origenes autorizados en google.developer.console pues sólo hemos agregado el server
Y para obtener el token,en el onSuccess:
 const id_token = googleUser.getAuthResponse().id_token;
 console.log(id_token);

Si diera error de que gapi no está definido quitar la carga asíncrona
 <script src="https://apis.google.com/js/platform.js" async defer></script>

Cambiarlo por un script normal,obligatorio y síncrono
 <script src="https://apis.google.com/js/platform.js"></script>

			VIDEO 174 USAR EL TOKEN DE GOOGLE PARA AUTENTICARNOS

Realmente es bastante fácil el servicio,simplemente va a llamar al backend con el token en cuanto lo tengamos de Google Sign In:

  loginGoogle(token:string){
    return this.http.post(`${base_url}/login/google`, {token})
    .pipe(
      tap( (resp:any) => {
        localStorage.setItem('token', resp.token);
      })
    );
  }

NOTA: la solución para que siempre me dé el popup para elegir cuentas es llamar al disconnect de esta API tras logearme,para no seguir logeados eternamente:
 attachSignin(element:any) {
    
  this.auth2.attachClickHandler(element, {},
     (googleUser:any) =>{
     const id_token = googleUser.getAuthResponse().id_token;
     console.log('Logged in as: ' + googleUser.getBasicProfile().getId());
     // Aqui ya tengo el token de google
      this.usuarioService.loginGoogle(id_token)
        .subscribe(() => {
        // this.router.navigate(['/']);
        this.auth2.disconnect();
        }
      );

ESte login está perfecto,voy a tener que cambiar el mío de Firebase por éste.Poco a poco.

				VIDEO 175 PROTEGER RUTAS DE MI APLICACIÓN

TEnemos que bloquear el /dashboard y sólo dejar pasar con un token válido.Lo haremos con un Guard:
ng g guard guards/auth --skip-tests <- y activo canActivate

Para usarlo hay que usarlo con la propiedad canActivate dentro de la instancia:Routes:

const routes: Routes = [
{ 
  path:'dashboard',
  component: PagesComponent,
  canActivate: [AuthGuard],
  children:[...]
}
En este caso como encima tiene varias rutas hijas protegemos a todas.Siempre va a proteger a esa ruta en concreto donde lo ponga o a ella+sus hijas.Genial.

Ya tengo una función que me permite ejecutar lógica en base a rutas,lógicamente tengo que retornar false si el token no existe o no es válido.

Y para comprobar el token ya tenemos un endpoint(el renew) que comprueba y además renueva,pero también comprueba,ojo.

* Podemos creaer un servicio como existe
  validarToken(){
    const token = localStorage.getItem('token') || '';

    return this.http.get(`${base_url}/login/renew`, 
    {
      headers: {
        'x-token': token,
      }
    }).pipe(
        tap((resp: any) => 
        {
          localStorage.setItem('token', resp.token);
        }),
        map( (resp: any) => {
          return resp.ok;
        }));
  }
* O también podría hacer la petición y en el guard retornar la resp.ok.Sea como sea está claro que tengo en esa propiedad ok el boolean para activar o no la ruta

  canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot) {
      return this.usuarioService.validarToken();
  }

IMPORTANTE: fijate que NO TENGO QUE DISPARAR EL OBSERVABLE!! Ya lo hará Angular cada vez que se intente entrar a esa ruta o rutas.Increíble
NOTA:fijate que si el Guard arroja un false el usuario se va a quedar en esa pantalla en blanco,sin poder hacer nada.TEngo que redireccionarle al login,por ejemplo.

Y para hacer esto inyecto el Router y fijate como el Guard tiene un Observable,asi que puedo usar pipe y con tap ver la respuesta:

    return this.usuarioService.validarToken()
      .pipe( tap(estaAutenticado => {
        if (!estaAutenticado) {
          this.router.navigateByUrl('/login');
        }
      }));

Añun faltaría manejar el error(ese 401 que nos dará un token caducado).De nuevo podemos hacerlo de varias formas,pero mejor usamos el operador rxjs catchError:
	return ...(pipe( tap... map...).
     catchError(err => {
          return of(false);
        }));

Fijate que yo tengo que retornar un Observable<boolean> asi que qué mejor que retrnar un of(false).Pero que grande es este cabrón.
Y por último redirecciono en el login | loginGoogle y el register inyectando Router:
 this.router.navigateByUrl('/'); | this.router.navigate(['/']);

					VIDEO 176 LOGOUT

De alguna manera queremos borrar el token del localStorage y además hacer el sign out de Google,todo esto en nuestro logout.
Empecemos por algo fácil,creando este servicio:

  logout() {
    localStorage.removeItem('token');
    
    this.auth2.signOut().then(() => {
      this.router.navigate(['/login']);
    });
Y lo llamo en el headerComponent y el sidebarComponent.Sin embargo,veo que tengo problemas,como no ver el botón o éste:

core.js:28064 Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?

Este error suele ser que he navegado usando alguna librería de terceros,sin usar el router de Angular.Es sólo un warning,pero efectivamente el problema está aquí: 
Efectivamente,la librería externa tiene dentro un router.navigate.
 this.auth2.signOut().then(() => {
      this.router.navigate(['/login']);

El warning es fácil de quitar,hay que inyectar NgZone,y usar su router:

constructor(
    private http: HttpClient,
    private router: Router,
    private ngZone: NgZone <- me traigo a NgZone
    });

Y que sea él el que rutee:
  this.auth2.signOut().then(() => {
      this.ngZone.run(() => {
      this.router.navigate(['/login']);
      });
    });
De echo,también tenemos un error al entrar,y es porque al entrar también estaba la librería manejando el ruteo:

Asi que en el loginComponent tmb usamos ngZone
   this.usuarioService.loginGoogle(id_token)
          .subscribe(() => {
            this.ngZone.run(() => {
            this.router.navigate(['/']);
            // this.auth2.disconnect();
            });

Si bien estaba funcionando la redirección Angular pierde por unos instantes el control sobre el ciclo de vida y es por esto que no se inicializan algunas funciones u otras cosas.

				VIDEO 177 OPTIMIZACION DEL AUTHINIT DE GOOGLE

Dado que hemos duplicado algo de código en la función que inicia la gapi mejor refactorizamos.Usaremos una Promesa,¿por qué?,porque a diferencia de los Observables se disparan sólas,no hace falta que nadie este escuchando:

   return new Promise(resolve => {
    console.log('init') <- esta Promise se dispara sola.

ASi que puedo compartir cualquier código metiendolo en una Promesa:
googleInit(){
    return new Promise(resolve => {
      gapi.load('auth2', () => {
        this.auth2 = gapi.auth2.init({
          client_id: '139109903112-ingc2d6nd9a88erptsdbglpsaonrrumm.apps.googleusercontent.com',
          cookiepolicy: 'single_host_origin',
        });
        resolve(this.auth2);
      });
    });
  }
Podía haberla echo void también,pero no es importante.Sea como sea ahora en vez de duplicar la inicialización llamo a la promesa que la inicia y me la devuelve:

  async startApp() {
      this.auth2 = await this.usuarioService.googleInit();
      this.attachSignin(document.getElementById('my-signin2'));
    }
Claro está ,hay que usar async/await y una variable local para almacenar a gapi.

			SECCION 15 PERFIL DE USUARIO,PIPES Y CARGA DE ARCHIVOS

Esta sección se enfoca en varios temas relacionados al perfil del usuario:

1- Módulo de pipes 
2- Pipe para controlar la imagen a desplegar
3- Subida de imagen desde el Front-end hasta el Back-end
4- Crear el componente del perfil del usuario
5- Notificar actualización de imagen
6- Vista previa de la imagen seleccionada en tiempo real (sin subirla al backend)

Al finalizar, siempre haremos la creación del release tag en nuestro repositorio local y remoto

				VIDEO 182 CONTINUACIÓN DEL PROYECTO

Levantamos todo de nuevo y retocamos el endpoint del renew token para que devuelva el user,ya que Fernando lo exige:

 const user = await Usuario.findById(uid);

  res.json({
    ok: true,
    token,
    usuario:user,

		VIDEO 183 CENTRALIZAR LA INFORMACIÓN DEL USUARIO CONECTADO

Queremos tener toda la información del usuario actual centralizada.UN buen punto para hacerlo es en el servicio para el canActivate del Guard.

Sin embargo,tengo que tener en cuenta que debo usar el Modelo que definí en Angular(una clase igual al Modelo del backend) e iniciar una instancia de él.
No debo hacer this.usuario = resp.data sino crea una instancia.

  const { email,google,nombre,role,img,uid } = resp.usuario;
  this.usuario = new Usuario(nombre, email, '',img, google,role,uid);

NOTA: puedo bajar el modo estricto de TS para no tener que hacer public usuario!:Usuario; en el tsconfig.json aqui: "strict": true, <- ponerlo a false

			VIDEO 184 MOSTRAR IMAGEN DEL PERFIL DEL USUARIO

Vamos a crear un getter que traiga la imagen.Pan comido:

  get getImagenUrl() {
    if (this.img.includes('https')) {
      return this.img;
    }else if(this.img){
      return `${ base_url }/upload/usuarios/${ this.img }`;
    }else{
      return `${ base_url }/upload/usuarios/no-image`;
    }
  }
FAlta llamar a este getter.Primero vamos al headerComponent.Fijate que en el video anterior metimos el modelo Usuario en una propiedad, asi que podría hacer refeerencia a la propiedad asi:

this.usuarioService.usuario.img pero vamos a usar el getter en el constructor:
 
  constructor(private usuarioService: UsuarioService) { 
    this.imgUrl = usuarioService.usuario.getImagenUrl;
  }

IMPORTANTE: el atributo [src]="imgUrl" necesita llaves cuadrada pues apunta a una propiedad de la clase.

Inclusive puedo traerme todo el modelo:

  public imgUrl = "";
  public usuario: Usuario;
  
  constructor(private usuarioService: UsuarioService) { 
  }
  
  ngOnInit(): void {
    this.imgUrl = this.usuarioService.usuario.getImagenUrl;
    this.usuario = this.usuarioService.usuario;
  }

NOTA:fijate que si no existe el campo img por ser un usuario normal y no haber subido foto MongoDB devuelve un undefined y el this.img.includes() de ese undefined rompe la aplicación.La solución es mirar primero por el campo img y despues por si lo incluye o no,no como hice yo de primeras.

				VIDEO 185 OPTIMIZACIONES DEL EMAIL 

IMPORTANTE: fijate que en Angular los dos {{}} sirven para meter código Javascript,no sólo sirven para inferir variables.Asi que vamos a mirar si el email es muy largo lo cortamos con el pipe slice y le contateno una ellipsis:

 <p class="text-muted">
    {{ usuario.email| slice:0:20 }}
    {{ (usuario.email.length > 20) ? "..." : "" }}
 </p>
NOTAS: fijate que he concatenado dos zonas {{}}{{}}.¿Y porqué no?Puedo concatenar todas las que quiera,y en React también.Y puedo usarlas para un ternario.Genial
Lo más importante es entender que puedo usar slice:0:20 para recortar cualquier variable fácil en Angular,además de usar ternarios y varios bloques.
		
			VIDEO 186 CREAR EL COMPONENTE DEL PERFIL DE USUARIO


