		SECCION 16 MANTENIMIENTO DE USUARIOS Y MODAL DE CARGA DE IMÁGENES

En esta sección veremos como mantener los usuarios.Implementaremos paginación,haremos busquedás,podremos cambiar el role,el nombre,crear usuarios,editarlos,borrarlos,..
Básicamentes será crear un CRUD por cada colección.Fernando me dará un consejo sobre como crear un cascarón reutilizable por CRUD y otro sobre estructurar el proyecto de mejor forma.

Esta sección tiene 2 objetivos generales, el primero es crear un mantenimiento de usuarios completo y el segundo, es crear un componente re utilizable que nos permita subir fácilmente imágenes de Hospitales, Usuarios y Médicos.

Veremos sobre:

1- Crear componente de usuarios
2- Búsqueda de usuarios
3- Borrar usuario
4- Actualizar Rol del usuario
5- Crear un modal para la subida de la imagen
6- Emitir notificaciones de cambio en imagenes

Al finalizar, tendremos respaldos locales y remotos, junto a su release tag

					VIDEO 197 CONTINUACION DEL PROYECTO

Arrancamos todo y vamos a crear otra sección en el sidebar.Recuerda que tenemos un servicio para hacer esto:

* En el sidebar.service.ts agrego otra posición al arreglo...  
menu: any[] = [
    { 
      titulo:'Dashboard',
      icono:'mdi mdi-gauge', 
      submenu:[
        {titulo:'Main', url:'/'},
        {titulo:'GraficaDona', url:'grafica-dona'},
        {titulo:'ProgressBar', url:'progress'},
        {titulo:'Promesas', url:'promesas'},
        {titulo:'Rxjs', url:'rxjs'},
      ]
    }
  ]
Fijate que nos habiamos dejado el icono.Fernando comenta que hay varias formas de enlazar la propiedad con la template:
<li *ngFor="let item of menuItems">
  <i [class]="item.icono"> <- si pongo [] en una propiedad interpreta JS en el sttring.
Otra forma,sin usar los [] es <i class="{{ item.icono }}",es decir o uso [] en el atributo o uso {{ }} en el valor.
Incluso puedo usar [ngClass]="item.icono".
NOTA:al implementar i18next puedo albergar los archivos json en el servidor o en le cliente,en el cliente pesará más la app,pero el acceso es más rápido(tratandose de texto diría que es la mejor opción).

					VIDEO 198 CREAR EL COMPONENTE DE USUARIOS

Trabajemos sobre este nuevo componente.Fijate como puedo usar las clases fa-<number>x sobre un icono de font awesome:

   <div class="alert alert-info text-center" role="alert">
          <h4 class="alert-heading">Cargando</h4>
          <i class="fa fa-spin fa-refresh fa-2x"></i>
          <p class="mb-0">Por favor,espere</p>
   </div>
Y como puedo crear un spinner con fa-spin + fa-refresh.Recuerda que fa-2x lo hace un poco más grande.

Traemos la tabla de la template y cambiamos los th y td por los de un usuario.ESto lo ponemos en un archivo aparte ya que nos hará de cascarón.Buena idea.

			VIDEO 199 CARGAR LOS USUARIOS DE FORMA PAGINADA

La petición debe ir al endpoint que ya devuelve los usuarios de forma paginada.Fijate que estamos repitiendo mucho código con los headers:

  cargarUsuarios(desde: number = 0) {
    return this.http.get(`${base_url}/usuarios?desde=${desde}`,{
      headers:{
      'x-token':this.token
    }});
  }
  
Hay varias cosas que podemos hacer,pero una muy sencilla dado que estamos en una clase es crearnos un getter que devuelva el objeto que necesito:

get headers(){
  return {
   headers: { 'x-token': this.token} 
} }

NOTA:Fijate que tenemos problemas para desestructurar en la Subscription.Esto es porque no hemos dicjo que devuelve el Observable.Hay varias formas de solucionar esto.

1ª: pasarle un objeto como tipo.Es válido pero muy feo el código  
 cargarUsuarios(desde: number = 0) {
    return this.http.get<{total:number;usuarios:Usuario[]}>(`${base_url}/usuarios?desde=${desde}`, this.headers);
  }

2ª: crear una interfaz:
export interface CargarUsuario {
  total: number;
  usuarios: Usuario[];
}
  cargarUsuarios(desde: number = 0) {
    return this.http.get<CargarUsuario>(`${base_url}/usuarios?desde=${desde}`, this.headers);
  }
Realmente parece más legible usar la segunda opción.
Como ya tengo el total y el arreglo de usuarios itero por la table con un NgFor.

					VIDEO 200 PAGINAR LOS USUARIOS

Realmente no es muy complicado implementar una paginación.Creo dos botones,uno que restará de 5 en 5 y otro que sume.ESto es fácil:
<button (click)="cambiarPagina(-5)" class="btn btn-secondary">Anterior</button>
<button (click)="cambiarPagina(+5)" class="btn btn-secondary ml-1">Siguiente</button>

  cambiarPagina(valor:number){
    /* si mando 5 desde será 5,despues 10,despues 15,etc... */
    this.desde += valor;
    /* controlo que nunca sea menor que 0 */
    if(this.desde < 0){
      this.desde = 0;
    }
    /* y que nunca sea mayor que lo que me traiga */ 
    if(this.desde > this.totalUsuarios){
      this.desde -= valor;
    }
    this.cargarUsuarios();
  }
En este caso cargarUsuarios hace la petición mediante el servicio al backend enviandole el desde(ya el propio backend me envia siempre los siguientes 5).Fácil.

Por último muestro condicionalmente la label de Google o byEmail:
 <span *ngIf="usuario.google" class="label label-danger">Google</span>  
 <span *ngIf="!usuario.google" class="label label-info">ByEmail</span>  

				VIDEO 201 DETALLES ESTÉTICOS DE LA PÁGINA

 Fernando observa que todas las columnas son recalculadas en cada paginación y aveces flashea un poco.Además,realmente no necesito que recalcule las columnas para avatar,acciones,auth y role,asi que las damos un tamaño fijo con una clase:

  <th class="w100">Avatar</th>
  <th>Email</th>
  <th>Nombre</th>
  <th class="w100">Role</th>
  <th class="w100">Auth</th>
  <th class="text-nowrap w100">Acciones</th>

Puedo observar que es una gran mejora visual.
Bien,para mostrar el avatar podemos tomar varios caminos,pero de la forma que estoy recibiendo la data no puedo simplemente llamar al getter pues no tipé el Observable así.
Podríamos hacer un customPipe,pero por fines educativos vamos a transformar la salida del Observable.Fijate que es muy interesante lo que hace:

cargarUsuarios(desde: number = 0) {
    return this.http.get<CargarUsuario>(`${base_url}/usuarios?desde=${desde}`, this.headers)
      .pipe( map(resp => {
          const usuarios = resp.usuarios.map( user => new Usuario(user.nombre, user.email, '',user.img, user.google,user.role,user.uid));

          return { 
            total: resp.total,
              usuarios
          };
        })
      );
  }
Mapea la respuesta y crea una nueva instancia de Usuario,y devuelve un arreglo de usuarios junto al total.Genial.

				VIDEO 202 MENSAJE DE CARGA DE INFORMACIÓN

Fijate que para mostrar el loading puedo crearme una propiedad boleana:
  
cargarUsuarios(){
    this.cargando = true;
    this.usuarioService.cargarUsuarios(this.desde)
    .subscribe( ({total,usuarios}) => {
      this.totalUsuarios = total;
        this.usuarios = usuarios;
        this.cargando = false;
    } );
  }
Incluso puedo usar el operador delay para ver como queda.Increíble.Ya sólo falta mostrar el loading con un *ngIf="cargando" y de paso se le puede poner un efecto de fade muy vistoso.

					VIDEO 203 BUSQUEDA DE USUARIOS  

La parte de buscar usuario es incluso más sencilla.Fijate que ya tengo un endpoint /api/todo/:coleccion/usuarios/e <- que me devuelve todos los usuarios que tengan la letra 'e'(puede que sea mejor startsWith en vez de includes()).

Además,como vamos a hacer tanto busquedas por usuarios como por medicos y hospitales mejor creamos un servicio sólo para buscar.

La función es mejor que reciba una enum con las colecciones,además del término.
Fijate que en mi app serían posts o usuarios.Genial

buscar(tipo:'usuarios'|'medicos'|'hospitales', termino:string) {

const url = `${base_url}/todo/coleccion/${tipo}/${termino}`;
    return this.http.get(url, this.headers)
      .pipe(
        map<any,any>( (resp) => resp.resultados)
      );
  }
Fijate que si no pongo que entra un any al map TS lo tomará como que entra un Ojbect y no va a poder hacer resp.resultados pues no existe en Object.Hay varias formas de solucionar esto,la mejor sería crear ahora los types pero vamos a usar any(también podia haber usado map( (resp:any) => resp.resultados).

Sea como fuere ya tengo mi servicio para buscar.Como es sólo un input es mejor no usar un formulario reactivo.Puedo hacer en el keyDown(al pulsar) o en el keyUp(al levantar).Lo haremos al levantar la tecla:

* Recuerda que Angular permite usar referencias locales en la template,es decir,que le puedo dar un nombre al cualquiera a ese HMTLElement.
 <input 
   #txtTermino
   (keyup)="buscar(txtTermino.value)"

Realmente ya tengo el término para buscar,jaja, y la colección ya la sé.Increible.Simplemente ya puedo disparar la petición mediante el servicio.

buscar(termino:string) {
  this.busquedaService.buscar('usuarios',termino)
  .subscribe( resultados => this.usuarios=resultados);

Esto meterá en la tabla los usuarios.claro que me trae todos porque el endpoint no está paginado,y no accede al avatar,etc.Hay que pulir más este servicio.

				VIDEO 204 PULIR LA BUSQUEDA DE USUARIOS

Puedo mostrar los botones de anterior y siguiente(o implementar una paginación) con un ngIf que mire si hay algo en el input:
<div *ngIf="txtTermino.value.length === 0">
  <button (click)="cambiarPagina(-5)" class="btn btn-secondary">Anterior</button>
  <button (click)="cambiarPagina(+5)" class="btn btn-secondary ml-1">Siguiente</button>
</div>
Sin embargo sería mejor implementar la paginación en el endpoint(hecho).Ahora bien,no podemos acceder al avatar por ese any,hay que transformar la respuesta 

  private transformarUsuarios(resultados: any[]): Usuario[] {
    return resultados.map(
      user => new Usuario(user.nombre, user.email, '',user.img, user.google,user.role, user.uid)
    );
  }
  
Esta vez le pasamos una función.
IMPORTANTE: recuerda que para este tipo de casos debo usar el operador debounceTime para que no bombardeen la DB con un tiempo razonable

	

