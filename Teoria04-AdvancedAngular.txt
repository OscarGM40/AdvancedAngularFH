		SECCION 16 MANTENIMIENTO DE USUARIOS Y MODAL DE CARGA DE IMÁGENES

En esta sección veremos como mantener los usuarios.Implementaremos paginación,haremos busquedás,podremos cambiar el role,el nombre,crear usuarios,editarlos,borrarlos,..
Básicamentes será crear un CRUD por cada colección.Fernando me dará un consejo sobre como crear un cascarón reutilizable por CRUD y otro sobre estructurar el proyecto de mejor forma.

Esta sección tiene 2 objetivos generales, el primero es crear un mantenimiento de usuarios completo y el segundo, es crear un componente re utilizable que nos permita subir fácilmente imágenes de Hospitales, Usuarios y Médicos.

Veremos sobre:

1- Crear componente de usuarios
2- Búsqueda de usuarios
3- Borrar usuario
4- Actualizar Rol del usuario
5- Crear un modal para la subida de la imagen
6- Emitir notificaciones de cambio en imagenes

Al finalizar, tendremos respaldos locales y remotos, junto a su release tag

					VIDEO 197 CONTINUACION DEL PROYECTO

Arrancamos todo y vamos a crear otra sección en el sidebar.Recuerda que tenemos un servicio para hacer esto:

* En el sidebar.service.ts agrego otra posición al arreglo...  
menu: any[] = [
    { 
      titulo:'Dashboard',
      icono:'mdi mdi-gauge', 
      submenu:[
        {titulo:'Main', url:'/'},
        {titulo:'GraficaDona', url:'grafica-dona'},
        {titulo:'ProgressBar', url:'progress'},
        {titulo:'Promesas', url:'promesas'},
        {titulo:'Rxjs', url:'rxjs'},
      ]
    }
  ]
Fijate que nos habiamos dejado el icono.Fernando comenta que hay varias formas de enlazar la propiedad con la template:
<li *ngFor="let item of menuItems">
  <i [class]="item.icono"> <- si pongo [] en una propiedad interpreta JS en el sttring.
Otra forma,sin usar los [] es <i class="{{ item.icono }}",es decir o uso [] en el atributo o uso {{ }} en el valor.
Incluso puedo usar [ngClass]="item.icono".
NOTA:al implementar i18next puedo albergar los archivos json en el servidor o en le cliente,en el cliente pesará más la app,pero el acceso es más rápido(tratandose de texto diría que es la mejor opción).

					VIDEO 198 CREAR EL COMPONENTE DE USUARIOS

Trabajemos sobre este nuevo componente.Fijate como puedo usar las clases fa-<number>x sobre un icono de font awesome:

   <div class="alert alert-info text-center" role="alert">
          <h4 class="alert-heading">Cargando</h4>
          <i class="fa fa-spin fa-refresh fa-2x"></i>
          <p class="mb-0">Por favor,espere</p>
   </div>
Y como puedo crear un spinner con fa-spin + fa-refresh.Recuerda que fa-2x lo hace un poco más grande.

Traemos la tabla de la template y cambiamos los th y td por los de un usuario.ESto lo ponemos en un archivo aparte ya que nos hará de cascarón.Buena idea.

			VIDEO 199 CARGAR LOS USUARIOS DE FORMA PAGINADA

La petición debe ir al endpoint que ya devuelve los usuarios de forma paginada.Fijate que estamos repitiendo mucho código con los headers:

  cargarUsuarios(desde: number = 0) {
    return this.http.get(`${base_url}/usuarios?desde=${desde}`,{
      headers:{
      'x-token':this.token
    }});
  }
  
Hay varias cosas que podemos hacer,pero una muy sencilla dado que estamos en una clase es crearnos un getter que devuelva el objeto que necesito:

get headers(){
  return {
   headers: { 'x-token': this.token} 
} }

NOTA:Fijate que tenemos problemas para desestructurar en la Subscription.Esto es porque no hemos dicjo que devuelve el Observable.Hay varias formas de solucionar esto.

1ª: pasarle un objeto como tipo.Es válido pero muy feo el código  
 cargarUsuarios(desde: number = 0) {
    return this.http.get<{total:number;usuarios:Usuario[]}>(`${base_url}/usuarios?desde=${desde}`, this.headers);
  }

2ª: crear una interfaz:
export interface CargarUsuario {
  total: number;
  usuarios: Usuario[];
}
  cargarUsuarios(desde: number = 0) {
    return this.http.get<CargarUsuario>(`${base_url}/usuarios?desde=${desde}`, this.headers);
  }
Realmente parece más legible usar la segunda opción.
Como ya tengo el total y el arreglo de usuarios itero por la table con un NgFor.

					VIDEO 200 PAGINAR LOS USUARIOS

Realmente no es muy complicado implementar una paginación.Creo dos botones,uno que restará de 5 en 5 y otro que sume.ESto es fácil:
<button (click)="cambiarPagina(-5)" class="btn btn-secondary">Anterior</button>
<button (click)="cambiarPagina(+5)" class="btn btn-secondary ml-1">Siguiente</button>

  cambiarPagina(valor:number){
    /* si mando 5 desde será 5,despues 10,despues 15,etc... */
    this.desde += valor;
    /* controlo que nunca sea menor que 0 */
    if(this.desde < 0){
      this.desde = 0;
    }
    /* y que nunca sea mayor que lo que me traiga */ 
    if(this.desde > this.totalUsuarios){
      this.desde -= valor;
    }
    this.cargarUsuarios();
  }
En este caso cargarUsuarios hace la petición mediante el servicio al backend enviandole el desde(ya el propio backend me envia siempre los siguientes 5).Fácil.

Por último muestro condicionalmente la label de Google o byEmail:
 <span *ngIf="usuario.google" class="label label-danger">Google</span>  
 <span *ngIf="!usuario.google" class="label label-info">ByEmail</span>  

				VIDEO 201 DETALLES ESTÉTICOS DE LA PÁGINA

 Fernando observa que todas las columnas son recalculadas en cada paginación y aveces flashea un poco.Además,realmente no necesito que recalcule las columnas para avatar,acciones,auth y role,asi que las damos un tamaño fijo con una clase:

  <th class="w100">Avatar</th>
  <th>Email</th>
  <th>Nombre</th>
  <th class="w100">Role</th>
  <th class="w100">Auth</th>
  <th class="text-nowrap w100">Acciones</th>

Puedo observar que es una gran mejora visual.
Bien,para mostrar el avatar podemos tomar varios caminos,pero de la forma que estoy recibiendo la data no puedo simplemente llamar al getter pues no tipé el Observable así.
Podríamos hacer un customPipe,pero por fines educativos vamos a transformar la salida del Observable.Fijate que es muy interesante lo que hace:

cargarUsuarios(desde: number = 0) {
    return this.http.get<CargarUsuario>(`${base_url}/usuarios?desde=${desde}`, this.headers)
      .pipe( map(resp => {
          const usuarios = resp.usuarios.map( user => new Usuario(user.nombre, user.email, '',user.img, user.google,user.role,user.uid));

          return { 
            total: resp.total,
              usuarios
          };
        })
      );
  }
Mapea la respuesta y crea una nueva instancia de Usuario,y devuelve un arreglo de usuarios junto al total.Genial.

				VIDEO 202 MENSAJE DE CARGA DE INFORMACIÓN

Fijate que para mostrar el loading puedo crearme una propiedad boleana:
  
cargarUsuarios(){
    this.cargando = true;
    this.usuarioService.cargarUsuarios(this.desde)
    .subscribe( ({total,usuarios}) => {
      this.totalUsuarios = total;
        this.usuarios = usuarios;
        this.cargando = false;
    } );
  }
Incluso puedo usar el operador delay para ver como queda.Increíble.Ya sólo falta mostrar el loading con un *ngIf="cargando" y de paso se le puede poner un efecto de fade muy vistoso.

					VIDEO 203 BUSQUEDA DE USUARIOS  

La parte de buscar usuario es incluso más sencilla.Fijate que ya tengo un endpoint /api/todo/:coleccion/usuarios/e <- que me devuelve todos los usuarios que tengan la letra 'e'(puede que sea mejor startsWith en vez de includes()).

Además,como vamos a hacer tanto busquedas por usuarios como por medicos y hospitales mejor creamos un servicio sólo para buscar.

La función es mejor que reciba una enum con las colecciones,además del término.
Fijate que en mi app serían posts o usuarios.Genial

buscar(tipo:'usuarios'|'medicos'|'hospitales', termino:string) {

const url = `${base_url}/todo/coleccion/${tipo}/${termino}`;
    return this.http.get(url, this.headers)
      .pipe(
        map<any,any>( (resp) => resp.resultados)
      );
  }
Fijate que si no pongo que entra un any al map TS lo tomará como que entra un Ojbect y no va a poder hacer resp.resultados pues no existe en Object.Hay varias formas de solucionar esto,la mejor sería crear ahora los types pero vamos a usar any(también podia haber usado map( (resp:any) => resp.resultados).

Sea como fuere ya tengo mi servicio para buscar.Como es sólo un input es mejor no usar un formulario reactivo.Puedo hacer en el keyDown(al pulsar) o en el keyUp(al levantar).Lo haremos al levantar la tecla:

* Recuerda que Angular permite usar referencias locales en la template,es decir,que le puedo dar un nombre al cualquiera a ese HMTLElement.
 <input 
   #txtTermino
   (keyup)="buscar(txtTermino.value)"

Realmente ya tengo el término para buscar,jaja, y la colección ya la sé.Increible.Simplemente ya puedo disparar la petición mediante el servicio.

buscar(termino:string) {
  this.busquedaService.buscar('usuarios',termino)
  .subscribe( resultados => this.usuarios=resultados);

Esto meterá en la tabla los usuarios.claro que me trae todos porque el endpoint no está paginado,y no accede al avatar,etc.Hay que pulir más este servicio.

				VIDEO 204 PULIR LA BUSQUEDA DE USUARIOS

Puedo mostrar los botones de anterior y siguiente(o implementar una paginación) con un ngIf que mire si hay algo en el input:
<div *ngIf="txtTermino.value.length === 0">
  <button (click)="cambiarPagina(-5)" class="btn btn-secondary">Anterior</button>
  <button (click)="cambiarPagina(+5)" class="btn btn-secondary ml-1">Siguiente</button>
</div>
Sin embargo sería mejor implementar la paginación en el endpoint(hecho).Ahora bien,no podemos acceder al avatar por ese any,hay que transformar la respuesta 

  private transformarUsuarios(resultados: any[]): Usuario[] {
    return resultados.map(
      user => new Usuario(user.nombre, user.email, '',user.img, user.google,user.role, user.uid)
    );
  }
  
Esta vez le pasamos una función.
IMPORTANTE: recuerda que para este tipo de casos debo usar el operador debounceTime para que no bombardeen la DB con un tiempo razonable

					VIDEO 205 BORRANDO USUARIOS	

Todo el mundo va a poder editar su propio usuario,pero sólo un admin podrá borrar al resto.Ya implementaremos esto.Además,mostraremos un pequeño promt antes de proceder al borrado.Sweetalert ya nos proporciona un prompt.
 
Fijate que además estoy en un *ngFor="let usuario of usuarios" asi que puedo mandar como argumento el usuario de esa row muy fácil:
 <a class="cursor" (click)="eliminarUsuario(usuario)">...

Sólo hay que crear un servicio que llame al endpoint de borrar.Fijate que Sweetalert ya me permite llamar a modales con aceptar/cancelar y mostrar otro si acepto:

  eliminarUsuario(usuario: Usuario) {

    Swal.fire({
      title: 'Borrar usuario',
      text: `Esta seguro que desea borrar a ${usuario.nombre}`,
      icon: 'question',
      showCancelButton: true,
      cancelButtonColor: '#d33',
      confirmButtonText: 'Si, borrarlo!',
      confirmButtonColor: '#3085d6',
    }).then((result) => {
      if (result.value) {
       // BORRAR EL USUARIO EN LA DDBB
        Swal.fire('Deleted', `${usuario.nombre} ha sido borrado`,
          'success');
      }
    });
  }
También faltó que cuando borro el registro 11 o 16,etc me vuelva a la paǵina anterior(va dentro del subscribe):
  this.totalUsuarios--;
  if(this.desde === this.totalUsuarios){
      this.desde -= 5;
  }
Y faltó que se borre correctamente tras buscar.

				VIDEO 206 FRONTEND- NO BORRARME A MI MISMO

Realmente no quiero borrar desde el frontend a mi como usuario.Fijate que es algo que debe controlarse ya desde el backend,realmente ha dejado alguna cosa sin hacer que hay que controlar.

  if (usuario.uid === this.usuarioService.usuario.uid) {
      Swal.fire('No puede borrar usuario', 'No se puede borrar a si mismo', 'error');
      return;
    }
    
					VIDEO 207 EDITAR EL ROL DEL USUARIO

Realmente ya teniamos como cambiar el name y el email,el tipo de auth no puedo cambiarlo,asi que sólo queda el rol.No vamos a usar otro botón,sino que usaremos un dropdown.
ES bastante sencillo:
  <td>
     <select class="form-controls" 
        [(ngModel)]="usuario.role"
        (change)="cambiarRole(usuario)">
        <option value="ADMIN_ROLE">Admin</option>
        <option value="USER_ROLE">User</option>
     </select>
  </td>
Fijate que con ngModel puedo enlazar cualquier propiedad,pero si es un select cogerá el valor como option selected.Genial.
Nos creamos un método para el onChange y le paso el usuario o el usuario.id.
 cambiarRole(usuario:Usuario){
   this.usuarioService.guardarUsuario(usuario)
    .subscribe((r)=>{
      console.log(r);
    })
 }
Realmente falta alguna cosa por controlar.Ya lo haremos.

			VIDEO 208 MODAL PARA LA CARGA DE IMAGENES REUSABLE

Queremos cambiar el avatar desde mantenimiento, y además hacerlo reusable para el futuro mantenimiento o CRUD de hospitales y médicos.
Como va a ser un componente que declararé en un modulo de reutilizables pero lo usaré en otro lado ojo que tengo que exportar este tipo de componentes reutilizables:
  exports: [
    IncrementadorComponent,
    DonaComponent,
    ModalImagenComponent

Recuerda subir este componente a un punto alto(aqui usaré Pages.component.html que está muy arriba).Así cualquier componente podrá abrir el modal:
<app-modal-imagen></app-modal-imagen> <- usar su selector en un punto alto

Bien,en cuanto a ese modal siempre debo ponerlo encima de un background-color con opacity:Esta clase para el div que ocupa toda la pantalla valdrá. 

.fondo-modal-imagen {
  background-color: rgba(0, 0, 0, 0.5);
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 999;
}

Para cerrarlo y ocultarlo hay que crearse una propiedad booleana:

  public mostrarModal:boolean=true;

  cerrarModal(){
    this.mostrarModal=false;
  }

			VIDEO 209 CONTROLAR EL MODAL Y CARGA DE IMAGENES

Dado que no vamos a usar muchos más de 10 servicios podemos tenerlos todos en una misma carpeta,pero si son demasiados es mejor separarlos.Asi pues creo un nuevo servicio para el modal:
ng g s services/modalImagen

Además,ya no vamos a tocar nada en el modalImagen si no es desde un servicio.Fijate como la inyección de dependencias no es porque la propiedad fuera privada:

 constructor(public modalService: ModalImagenService) { }

* Nos vamos a traer la instancia como publica,esto hará que se pase todo por referencia(confirmar que una inyección privada no pasa por referencia y una pública sí).Confirmo ya que si no la inyecto publica no puedo acceder al servicio en la template,esta es la primera gran diferencia,que puedo usar el servicio en la template:

<div class="fondo-modal-imagen animated fadeIn fast"
 [class.oculto]="modalImagenService .ocultarModal"
>

Fijate que usar el servicio en la template me abre un abanico inmenso de posibilidades.Ahora cerrarModal en el modal llama al cerrarModal del servicio que cambia su propiedad privada,la cual tiene el getter que tenemos enganchado a la clase dinámica 'oculto'.Genial,queda desacoplado.

Ahora simplemente llamamos en el click sobre el avatar al abrirModal del service.Está perfecto.
Fijate que pasar esto por referencia es clave:
<div class="fondo-modal-imagen animated fadeIn fast"
 [class.oculto]="modalImagenService .ocultarModal"
>
Si usara otra forma tendría que hacer cambios.

				VIDEO 210 CARGAR IMAGENES USANDO EL MODAL

Realmente ya tengo casi toda la lógica hecha en el updateProfile que hicimos.Me traigo las dos img y el input type file y sus dos métodos.En el servicio haremos la lógica,pero primero al pulsar en el avatar le paso el usuario como argumento y lo envio a un método del servicio:

* En el click del avatar llamo a abrirModal con el usuario como arg:
<img 
  src="{{usuario.getImagenUrl}}" 
  alt="avatarUsuario"
  class="mini-avatar cursor"
  (click)="abrirModal(usuario)"
 >

En la clase lo recogo y llamo al servicio con los argumentos necesarios

 abrirModal(usuario: Usuario) {
   this.modalImagenService.abrirModal('usuarios', usuario.uid!, usuario.img);
  }

Ese abrirModal del service(no confundir nombres):
  
abrirModal(
    tipo:'usuarios' | 'medicos' | 'hospitales',
    id: string,
    img: string ='no-img'
  ) {
    this._ocultarModal = false;
    this.tipo = tipo;
    this.id = id;
    if(img.includes('https')){
      this.img = img;
    }else {
      this.img = `${base_url}/upload/${tipo}/${img}`;
    }
  }
Puedo ver que ya hace el switch de imagenes y que carga la actual al abrir el modal.Sin embargo,aún falta guardarlo en la DB.
Por último,fijate como he referenciado desde la clase a un elemento cualquiera de el .html correspondiente sin usar ViewChild y le he cambiado el valor:

(<HTMLInputElement>document.getElementById('imagen')).value =''; Genial.

			VIDEO 211 ACTUALIZAR LA IMAGEN DEL USUARIO DESDE EL MODAL 

Realmente ya tengo creada la lógica asi que puedo copiar el método e inyectar el servicio que hace la petición.Tendrá un par de cambios,ya que el id lo tengo ya en el modalService:

  guardarAvatar() {

    const id = this.modalImagenService.id;
    const tipo = this.modalImagenService.tipo;

    this.fileUploadService
      .actualizarFoto(this.imagenSubida, tipo, id)
      .then(img => {
        Swal.fire('Guardado', 'Avatar actualizado', 'success');
        this.cerrarModal();
      })
      .catch((error) => {
        console.log(error);
        Swal.fire('Error', error.error.msg, 'error');
      });
  }
Sin embargo,falta avisar al componente que la imagen se actualizó.Hay varios caminos para esto,como usar un Observable o un EventEmitter que emita algo cuando hay que actualizar el componente en el modalService.Genial.

 /* para informar de una nueva imagen usaremos la clase EventEmitter.Realmente puedo emitir lo que quiera.Emitiremos un string */
public nuevaImagen: EventEmitter<string> = new EventEmitter<string>();

Recuerda que para emitir era con emit():

 guardarAvatar() {

    const id = this.modalImagenService.id;
    const tipo = this.modalImagenService.tipo;

    this.fileUploadService
      .actualizarFoto(this.imagenSubida, tipo, id)
      .then(img => {
        Swal.fire('Guardado', 'Avatar actualizado', 'success');
        /* aqui sé que se subió la imagen */
        this.modalImagenService.nuevaImagen.emit(img);

IMPORTANTE!: esta propiedad nuevaImagen es un Observable,un EventEmitter es un Observable y me permite subscribirme,usar operadores,... solo que emito valores con emit en vez de con next.

En el usuarios.cmponent escucho en el ngOnInit por un cambio y recargo todos los usuarios si lo hay.Sólo necesito recargar los Usuarios,pero con un pequeño delay para que suba la imagen al servidor 

 this.imgSubs =  this.modalImagenService.nuevaImagen
      .pipe(delay(100))
      .subscribe(img => this.cargarUsuarios());
  }

Por último,no tiene sentido que yo mantenga esta subscripción afuera de este componente.asi que la destruyo al salir de este componente que es el mantenimiento de usuarios.Fijate que tendré que hacer lo mismo para los otros dos y cómo es una gran idea hacerlo.

  ngOnDestroy(): void {
    this.imgSubs.unsubscribe();
  }

			SECCION 15 MEDICOS Y HOSPITALES CRUD/MANTENIMIENTO

El crud de hospitales será sencillo,el nombre y el creador.El de médicos tendrá algo más de complejidad.

Esta sección tiene por objetivo poner a prueba todo lo aprendido hasta el momento, hay una tarea bastante grande que pueden demorar mínimo unos 20 minutos en hacerla  (si no se equivocan en nada)

Pero puntualmente, estos son los temas:

1- Explicación de la tarea
2- Documentos de la tarea
3- Detalles sobre el pipe de las imagenes
4- Resolución de la tarea
5- Componente de Médico y Médicos
6- Borrar médicos
7- Crear nuevo médico
8- Mostrar información en base a una selección de un hospital
9- Cargar médico
10- Actualizar registro de un médico

Al finalizar, tendremos respaldo en GitHub, release tag y commits locales para proteger nuestro trabajo

				VIDEO 216 DISEÑO DE LA PANTALLA DE HOSPITALES

Empezamos creando los componentes por cli,modificando las rutas en el .routes y copiando el cascarón.

				VIDEO 217 MODELO Y SERVICIO PARA HOSPITALES	

Creo el modelo(que será una clase).Esta vez vamos a usar un pipe para la foto/avatar en vez de un método.

IMPORTANTE: ¿como saber si debo usar una clase o una interfaz?Si necesito métodos mejor usar una clase.Además,siempre puedo empezar con una interfaz y cambiar a una clase si hace falta.

interface _hospitalUser {
  _id: string;
  nombre: string;
  img: string;
}

export class Usuario {

  constructor(
    public nombre: string,
    public _id?: string,
    public img?: string,
    public usuario?:_hospitalUser,
  ) { }

}

Fijate que hemos tenido que crear una interfaz para tipar el usuario,que tiene sólo unas pocas propiedades.

Creo un servicio que haga el GET:
  cargarHospitales(desde: number = 0) 
  {
    return this.http.get(`${base_url}/hospitales?desde=${desde}`, this.headers)
  }
Esta vez no transformamos creando una instancia,dado que usaremos un pipe.

Fijate que puedo usar un object type annotation en un genérico:

return this.http.get<{ ok: boolean, hospitales: Hospital[] }
Aunque puede que tenga que tipar los headers:
 get headers(): any  {

Sea como sea esta solución parece buena:
cargarHospitales(desde: number = 0) 
  {
    return this.http.get(`${base_url}/hospitales?desde=${desde}`, this.headers).pipe(
      map<any,Hospital[]>( (resp:{ok:boolean,hospitales:Hospital[],total:number}) => resp.hospitales));
  }

			VIDEO 218 MOSTRAR LOS HOSPITALES EN LA TEMPLATE

En el componente llamamos al servicio,habrá que crearse una propiedad para recoger el arreglo de hospitales además de un boleano para el loading:

   <tr *ngFor="let hospital of hospitales">
      <td>{{hospital.img}}</td>
      <td>
         <input type="text" 
            class="form-control"
            placeholder="Nombre del hospital"
            [(ngModel)]="hospital.nombre">
      </td>
NOTA:fijate como [(ngModel)] hace como el "value" metiendo el nombre como valor.recuerdalo,es importante.

			VIDEO 219 PIPES PARA MOSTRAR LAS IMÁGENES

Fijate que no hemos creado una instancia de Hospital,asi que no tengo accesos a métodos o getters a través de esa instancia.Lo que vamos a hacer es generar un pipe:
ng g pipe pipes/imagen --skip-tests

Fijate que al haberlo creado en la raiz me lo va a importar al app.module.ts.No vamos a hacer esto,pues la aplicación podria crecer mucho el día de mañana y por tanto este archivo raiz app.module tendría todos los pipes.Mejor creamos un modulo sólo para pipes y lo requerimos en cada otro modulo que vaya a usar un pipe:
ng g m pipes/pipes --flat <- generará pipes.module.ts

@NgModule({
  declarations: [
    ImagenPipe
  ],
  exports: [
    ImagenPipe
  ],
})
export class PipesModule { }
Lo declaro y exporto.
Recuerda que en pocas palabras un pipe me sirve para transformar la forma visual de como recibo la información.
Es decir,yo puedo recibir un string y modificarlo(capitalizandolo,por ejemplo) pero en realidad no lo cambié,sólo a la hora de mostrarlo por la UI el usuario lo verá de esta forma,pero el string sigue siendo en minúsculas.

Además,un pipe siempre implementa la interfaz PipeTransform y debe desarrollar su método transform:
export class ImagenPipe implements PipeTransform {

  transform(value: unknown, ...args: unknown[]): unknown {
    return null;
  }

Recuerda que lo que le pase como name será el nombre a llamar para el pipe:
@Pipe({
  name: 'MiImagenPipe'
})
Ya sólo falta llamarlo,pero,ojo,recuerda que mi pipe al final lleva dos argumentos y se llama MiImagenPipe:
 <td>{{hospital.img | MiImagenPipe:'hospitales'}}
Esto dará la siguiente salida:
hola mundoundefined hospitales <- cualquier argumento que falte será un undefined

Creemos la lógica del pipe correctamente.No puede ser más sencillo:
export class ImagenPipe implements PipeTransform {

  transform(
    img:string,
    tipo:'usuarios' | 'medicos' | 'hospitales'): string {

    if (img) {
      if (img.includes('https')) { return img; }
      return `${base_url}/upload/${tipo}/${img}`
    } else {
      return `${base_url}/upload/${tipo}/no-image`
    }
  }
}
IMPORTANTE:tengo dos formas para inferir el string que devuelve este pipe.La primera es SI usar corchetes en el atributo y NO usar dobles llaves en el valor:
<img [src]="hospital.img | MiImagenPipe:'hospitales'"
LA segunda es NO usar corchetes y SIusar dobles llaves en el atributo:
<img src="{{hospital.img | MiImagenPipe:'hospitales'}}"
Como puedo ver nunca va todo junto (o corchete y no llaves o llaves y no corchetes)

			VIDEO 220 CRUD DEL SERVICIO Y BOTON CREAR HOSPITAL

NOTA. fijate como Fernando centra con las clases text-<direction>.
<div class="text-right d-flex justify-content-end"> 
  <button class="btn btn-primary d-flex align-items-center justify-content-center">
    <i class="fa fa-hospital-o fa-2x mr-2"></i>
       Crear Hospital
  </button>
</div>

El crud no tiene complicación alguna:
  /* POST */
  crearHospital(nombre: string) 
  {
    return this.http.post(`${base_url}/hospitales`,{ nombre }, this.headers);
  }
  /* PUT */
  actualizarHospital(_id:string, nombre: string) 
  {
    return this.http.put(`${base_url}/hospitales/${_id}`,{nombre}, this.headers);
  }
  /* DELETE */
  borrarHospital(_id:string) 
  {
    return this.http.delete(`${base_url}/hospitales${_id}`, this.headers);
  }
Recuerda que el argumento id va el primero por ser el más importante.

		VIDEO 221 FUNCIONALIDAD DEL MANTENIMIENTO DE HOSPITALES

NOTA.de nuevo fijate como usa text-nowrap + w100 para usarlo como min-content ó max-content.

Fijate como quitar el atributo href a una <anchor> hace que pierda el cursor:pointer y se lo tengo que poner yo.

Bien,ni guardar ni eliminar tienen complejidad:

  guardarCambios(hospital:Hospital){
    // console.log(hospital);
     this.hospitalService.actualizarHospital(
      hospital.id!, hospital.nombre)
      .subscribe(resp => {
        Swal.fire('Hospital actualizado', hospital.nombre, 'success');
      }); 
  }

  eliminarHospital(hospital:Hospital){
    console.log(hospital);
     this.hospitalService.borrarHospital(hospital.id!)
      .subscribe(resp => {
        this.cargarHospitales();
        Swal.fire('Hospital eliminado', hospital.nombre, 'success');
      });  
  }

Pero para crear un Hospital vamos a usar Swal también,con el doble modal.
IMPORTANTE:fijate que con Swal puedo usar inputs para recibir data.Además,perfectamente puedo trabajar en base a Promesas:

async abrirSweetAlert() {
  const valor = await Swal.fire({
  input:'text',
  inputPlaceholder: 'Insertar nombre del Hospital'
  )}
*Puedo ver que en el objeto valor siempre tengo el valor del input en el atributo value asi que puedo desestructurar:
const  {value} = await Swal.fire... <- claro que es para un Swal que recoga un valor.

Con todo esto simplemente compruebo que venga algo en el input y guardo el  nuevo hospital.
  async nuevoHospital() {
  
   const { value } = await Swal.fire<string>({
      title: 'Crear hospital',
      text: 'Ingrese el nombre del hospital',
      input: 'text',
      inputPlaceholder: 'Nombre del hospital',
      showCancelButton: true,
      confirmButtonText: 'Crear',
      cancelButtonText: 'Cancelar',
      showLoaderOnConfirm: true,
    });

    if (value!.trim().length > 0) {
      this.hospitalService.crearHospital( value!)
        .subscribe( (resp:any) => {
          this.hospitales.push(resp.hospital);
        });
    }
Perfecto.lo último que nos falta es la parte de actualizar la imagen.Recuerda que tenemos un modalService para esto ya creado.

  abrirModal(hospital:Hospital){
    this.modalImagenService.abrirModal('hospitales', hospital.id!, hospital.img);
  }

Recuerda que en el OnInit nos suscribiamos a un EventEmitter para hacer el refresh:
  ngOnInit(): void {
    this.cargarHospitales();

    this.modalImagenService.nuevaImagen
      .pipe(delay(100))
      .subscribe( (data) => {
      this.cargarHospitales();
    });

  }

							VIDEO 222 BUSQUEDA DE HOSPITALES

IMPORTANTE:anteriormente si no se mandaba un valor en el input del swal de crear un hospital value toma el valor de undefined y hacer el trim a undefined tiraba la aplicación.Es tan sencillo como asignarle un valor por defecto pero fijate como el trim de undefined es un error fatal:
const { value="" } = await Swal.fire<string>({
    if (value!.trim().length > 0) { <- undefined.trim() es malo asinto

Fijate que es buena idea crear los types necesarios.Ni siquiera van a compilar asinto:
 buscar(termino: string) {

    if (termino.length < 0) {
      this.hospitales = this.hospitalesTemp;
      return;
    }

    if(termino.length === 0) {
     return this.cargarHospitales();
    }

    this.busquedaService.buscar('hospitales', termino, 0)
      .subscribe((resp:HospitalesResponse) => {
        this.totalBusqueda = resp.total;
        this.hospitales = resp.hospitales;
      });
  }
				
			VIDEO 223 COMPONENTE PARA MEDICOS Y MEDICOS-SERVICE

Primero creamos el modelo para el médico.Fijate que las propiedades opcionales deben ir las últimas:
interface MedicoUser {
  id: string;
  nombre: string;
  img: string;
}

interface MedicoHospital {
  id: string;
  nombre: string;
  img: string;
}

export class Medico {

  constructor(
    public nombre: string,
    public id?: string,
    public img?: string,
    public usuario?: MedicoUser,
    public hospital?: Hospital,
  ) { }
}

Adicionalmente vamos a crear un componente Medico para la ruta con el param obligatorio medico/:id.

   { path:'medicos', component: MedicosComponent, data: { title: 'Mantenimiento de Medicos' } },
   { path:'medico:/id', component: MedicoComponent, data: { title: 'Mantenimiento de Medicos' } },

Fijate que perfectamente puedo tener 4 archivos en un componente,asi que meto medico.component.html y medico.component.ts en el mismo folder de medicos.Aunque no es importante y podría crear el folder semánticamente tiene mucho sentido agruparlos.
Finalmente implemento el cascaron.txt en medicos.component.html

		VIDEO 224-225 IMPLEMENTAR CRUD Y REDIRECCIONAR A MEDICO-COMPONENT

Realmente implementar el Crud de nuevo es copiar y pegar.No obstante queremos redireccionar a la pantalla de médico para editarlo.
Para redireccionar tengo varias sintaxis,pero usaré en todas ellas el routerLink de Angular:

1-  <a routerLink="/dashboard/medico/{{medico.id}}"> <-forma uno todo dentro del string
2- <a [routerLink]="['/dashboard/medico',medico.id]"> <-forma dos, con un array,lo cual implica corchetes para interpretar ese array.Además,fijate que 'medico' es un string,pero medico.id no(pero si es un string xd) 
3- <a [routerLink]="['/dashboard','medico',medico.id]"> <- igual que la dos pero segmentando la ruta.

Recuerda que la Subscription al EventEmitter para el autorefresh hay que destruirlo en el OnDestroy:

 ngOnDestroy(): void {
    if (this.imgSubs) {
      this.imgSubs.unsubscribe();
    }
  }

Por último creamos un botón que rediriga a /nuevo.Con este param sabŕe que quiero crear a diferencia de si es el id que será editar uno ya existente.Genial.

			VIDEO 227 COMPONENTE MÉDICO - ESTRUCTURA DEL HTML


