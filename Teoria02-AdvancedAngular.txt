					SECCION 09 EMPEZANDO EL BACKEND

Esta sección tiene como objetivo preparar todo lo necesario para comenzar a crear nuestro backend server:

1- Configuración de Mongo
2- Robo 3T
3- Conexión entre Mongo y Node
4- Tip sobre colores de consola
5- Aprender un poco sobre los errores de respuestas HTTP
6- Configuración inicial de Express
7- Establecer las bases de nuestros RESTful services

Al finalizar, crearemos un nuevo repositorio en GitHub para almacenar nuestro backend server y así tenerlo listo en caso de que necesitemos implementar un nuevo backend server rápidamente

						VIDEO 90 INICIO BACKEND

Fijate que   "keywords": [], es para dar palabras clave si voy a usar el registro de repos de npm.
Recuerda que jamás debo modificar el package.lock.json manualmente
NOTA: fijate que lo mejor es instalar nodemon de manera global en el sistema y así no tengo que instalarlo en el proyecto

Fijate que los códigos 200 son respuestas exitosas,los 300 redirecciones(movimiento de recursos),los 400 son que nosotros hicimos mal la petición.Los 500 son errores directamente relacionados con el servidor.

Fijate como lanzar un new Error me va a ser suficiente,asinto.No hace falta matar el proceso(diría que es mala idea):
export const dbConnection = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
      useCreateIndex: true,
      useFindAndModify: false,
    });
    console.log("MongoDB Connected to " + mongoose.connection.name);
  } catch (error) {
    console.log(error.message);
    throw new Error('Error a la hora de iniciar la DB.Ver logs') <- creo que simplemente tirar el error es suficiente
  }
};

NOTA: desde mongoose 6+ las opciones ya vienen implicitas en el método connect() ya no son necesarias,estaban de forma provisional.
MOngoose es un ODM(mapeador de Documentos), no es lo mismo que Sequelize que es un ORM(Mapeador de Relaciones)

NOTA:todo lo que grabe en un .env son STRINGS(PORT=3005,ese 3005 es un string).
Además,nodemon sólo está pendiente de cambios en archivos de Javascript y ese .env no es un archivo de Javascript asi que cuando haga cambios en los archivos de variables de entorno tengo que parar y levantar de nuevo la app.

NOTA: los middlewares se ejecutan en cada petición,asi pues app.use(cors()) o  app.use(express.json()) se ejecutan de nuevo en cada petición ,porque son un middleware.

Fijate que si Git está dando seguimiento al folder node_modules lo veré en verde,o con algun carácter sobre él.Es la prueba de que algo hice mal.

				SECCION 10 BACKEND DE USUARIOS

El control de usuarios es algo torácico y fundamental en una aplicación.
Esta sección tiene por objetivo trabajar fuertemente con Express, Mongo y Node:

1- Explicación general y alcances del Backend
2- Crear colección de Usuarios
3- Crear modelos en Node
4- POST
5- Validaciones automáticas mediante Mongoose
6- Encriptar contraseñas
7- PUT
8- Delete
9- Get
10- Login de Usuario
11- Generación de un JWT
12- Middlewares
13- Optimizar Middlewares

Al finalizar, actualizaremos nuestro repositorio en GitHub para mantener un respaldo de nuestro código local y remotamente

			VIDEO 104 PANORAMA GENERAL DEL BACKEND

Vamos a crear una aplicación de hospitales.Tendrá tres tablas,usuarios,médicos y hospitales.
Los usuarios están relacionados con los médicos(más bien pacientes).
Los médicos se relacionan con los hospitales y los hospitales también se relacionan con los médicos.

Campos del Modelo Usuario/Paciente:
nombre(required),email(required,unique),password(required,encryptedOneWayHash),img(optional),role(required,default,enum),createdByGoogle(boolean,optional).

Campos del Schema Médicos:
nombre,img,usuario(ref),hospital(ref)

Campos del Modelo Hospital:
nombre,img,usuario

Vamos a añadir diversas features como un buscador(fijate que necesito esto en mi social net),también vamos a añadir un remember me para el email y comprobar el token que envia Google si el usuario se logea por Google.
También habrá paginación,carga de imágenes y archivos,bloqueo de imágenes(mediante filesystem,mediante url y otra que necesite estar autenticado).
Generaremos el token,lo verificaremos y validaremos el token de Google(mandarla al backend y si coincide entonces si creo el usuario).

					VIDEO 105 CREANDO EL MODELO DE USUARIO

Creo el modelo como cualquier otro:
const mongoose = require('mongoose');


const UsuarioSchema = new mongoose.Schema({
   nombre: { type: String, required: true },
   email: { type: String, required: true, unique: true },
   password: { type: String, required: true },
   img: { type: String, },
   role: { type: String, required: true, default: 'USER_ROLE' },
   google: { type: Boolean, default: false },
},{
   timestamps: true,
   versionKey: false
});

module.exports = mongoose.model('Usuario', UsuarioSchema);
Fijate que no tiene relaciones hacia él.

			VIDEO 106 EMPEZANDO CON LAS RUTAS Y LOS CONTROLADORES

Empiezo creando el getUsuarios.Vamos a separar las rutas de los controladores.Fijate como FH recomienda poner el cada file de rutas la ruta al principio:

/* Ruta: '/api/usuarios */
const router = require('express').Router();
const { getUsuarios } = require('../controllers/usuarios.controller');

/*  */
app.get('/',getUsuarios);

module.exports = router;

Asi sabré en cuanto mire el archivo que es /api/usuarios y no tengo que ir al index.Parece buena idea.

				VIDEO 107 POST- CREAR USUARIO

Simplemente creamos el controlador.

		VIDEO 108 TERMINAR EL GET DE LOS USUARIOS

Muy dificil asinto.

			VIDEO 109 VALIDAR QUE EL EMAIL SEA UNIQUE

zzzzzz

				VIDEO 110 VALIDAR CAMPOS OBLIGATORIOS

Ya existen multitud de librerias con funcionalidad para manejar validaciones.Sin embargo usaremos express-validator cual asintos. 
Recuerda que como segundo argumento en las rutas puedo usar o un único middleware o un array con todos ellos(pero siempre será un único argumento:

router.get('/',middleware,controlador) ó bien
router.get('/',[middlewareA,middlewareB,middlewareC],controlador)

Recuerda que desde cierta versión ya no se usa el middleware body sino el check:

const { check } = require('express-validator');

router.post('/',[
   check('nombre','El nombre es obligatorio').not().isEmpty(),
   check('email','El email es obligatorio').isEmail(),
   check('password','El password es obligatorio').not().isEmpty()
   ],crearUsuario);

Y recuerda que esto realmente no hace nada,hay que ir al controlador y mapear los errores que pueda tener cada request tras pasar por el check.

  const errores = validationResult(req);
  
  if (!errores.isEmpty()) {
    return res.status(400).json({
      ok: false,
      errores: errores.mapped(),
    });
  }

IMPORTANTE: recuerda que es un error copiar y pegar este código por cada controlador.Es tremendamente importante crear una función helper que abstraiga la lógica.

				VIDEO 111 MIDDLEWARE PERSONALIZADO

Realmente abstraer la lógica de la devolución de los errore es muy fácil:

const { validationResult } =require("express-validator");

exports.validarCampos = (req= request,res= response,next) => {
   
   const errores = validationResult(req);

   if (!errores.isEmpty()) {
      return res.status(400).json({
         ok: false,
         errores: errores.mapped(),
      });
   }  
   next();
}

Luego hay que usarlo,pero ojo,debe ir el último por motivos obvios.

			VIDEO 112 ENCRIPTAR CONTRASEÑA USANDO ONEWAYHASH

Para encriptar vamos a usar bcryptjs asi que lo instalamos.	Lo vamos a hacer de forma síncrona esta vez:
const bcrypt = require("bcryptjs");

const salt = bcrypt.genSaltSync();
usuario.password = bcrypt.hashSync(password,salt) <- ya tenia password desestructurado.

Aún nos faltaria devolver el token,entre otras cosas.

				VIDEO 113 PUT - Actualizar un usuario


m
rts.actualizarUsuario = async (req = request, res = response) => {
  // TODO validar token
  const uid = req.params.id;
  const { nombre, email, password, role } = req.body;

  try {
    const usuarioDB = await Usuario.findById(uid);

    if (!usuarioDB) {
      return res.status(404).json({
        ok: false,
        msg: "Usuario no encontrado",
      });
    }

    
    usuarioDB.nombre = nombre;
    if (usuarioDB.email !== email) {
      const existeEmail = await Usuario.findOne({ email });
      
      if(!existeEmail) {
        usuarioDB.email = email;
      }else{
        return res.status(400).json({
          ok: false,
          msg: "El correo ya existe",
        });
      }

    }
    usuarioDB.role = role;

    if (password) {
      const salt = bcrypt.genSaltSync();
      usuarioDB.password = bcrypt.hashSync(password, salt);
    }

    await usuarioDB.save();

    res.json({
      ok: true,
      usuario: usuarioDB,
    });
  } catch (error) {
    console.log(error);
    res.status(500).json({
      ok: false,
      msg: "Error inesperado",
    });
  }
};

				VIDEO  115 DELETE BORRAR UN USUARIO

Hoy en día no se recomienda realmente borrar un usuario de una DB.Es mejor usar un simple boleano isActive por si un día vuelve.
NOTA: no hay ningun problema en que tenga una petición DELETE y realmente no borre nada.Se recomienda desactivar los usuarios y no borrarlos.

exports.borrarUsuario = async (req = request, res = response) => {
  const uid = req.params.id;

  try {
    const usuarioDB = await Usuario.findById(uid);

    if (!usuarioDB) {
      return res.status(404).json({
        ok: false,
        msg: "Usuario no encontrado",
      });
    }

    usuarioDB.isActive = false;
    await usuarioDB.save();

VIDEO ..

Hoy en día no se recomienda realmente borrar un usuario de una DB.Es mejor usar un simple boleano isActive por si un día vuelve.
NOTA: no hay ningun problema en que tenga una petición DELETE y realmente no borre nada.Se recomienda desactivar los usuarios y no borrarlos.

exports.borrarUsuario = async (req = request, res = response) => {
  const uid = req.params.id;

  try {
    const usuarioDB = await Usuario.findById(uid);

    if (!usuarioDB) {
      return res.status(404).json({
        ok: false,
        msg: "Usuario no encontrado",
      });
    }

    usuarioDB.isActive = false;
    await usuarioDB.save();

VIDEO ....
