					SECCION 09 EMPEZANDO EL BACKEND

Esta sección tiene como objetivo preparar todo lo necesario para comenzar a crear nuestro backend server:

1- Configuración de Mongo
2- Robo 3T
3- Conexión entre Mongo y Node
4- Tip sobre colores de consola
5- Aprender un poco sobre los errores de respuestas HTTP
6- Configuración inicial de Express
7- Establecer las bases de nuestros RESTful services

Al finalizar, crearemos un nuevo repositorio en GitHub para almacenar nuestro backend server y así tenerlo listo en caso de que necesitemos implementar un nuevo backend server rápidamente

						VIDEO 90 INICIO BACKEND

Fijate que   "keywords": [], es para dar palabras clave si voy a usar el registro de repos de npm.
Recuerda que jamás debo modificar el package.lock.json manualmente
NOTA: fijate que lo mejor es instalar nodemon de manera global en el sistema y así no tengo que instalarlo en el proyecto

Fijate que los códigos 200 son respuestas exitosas,los 300 redirecciones(movimiento de recursos),los 400 son que nosotros hicimos mal la petición.Los 500 son errores directamente relacionados con el servidor.

Fijate como lanzar un new Error me va a ser suficiente,asinto.No hace falta matar el proceso(diría que es mala idea):
export const dbConnection = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
      useCreateIndex: true,
      useFindAndModify: false,
    });
    console.log("MongoDB Connected to " + mongoose.connection.name);
  } catch (error) {
    console.log(error.message);
    throw new Error('Error a la hora de iniciar la DB.Ver logs') <- creo que simplemente tirar el error es suficiente
  }
};

NOTA: desde mongoose 6+ las opciones ya vienen implicitas en el método connect() ya no son necesarias,estaban de forma provisional.
MOngoose es un ODM(mapeador de Documentos), no es lo mismo que Sequelize que es un ORM(Mapeador de Relaciones)

NOTA:todo lo que grabe en un .env son STRINGS(PORT=3005,ese 3005 es un string).
Además,nodemon sólo está pendiente de cambios en archivos de Javascript y ese .env no es un archivo de Javascript asi que cuando haga cambios en los archivos de variables de entorno tengo que parar y levantar de nuevo la app.

NOTA: los middlewares se ejecutan en cada petición,asi pues app.use(cors()) o  app.use(express.json()) se ejecutan de nuevo en cada petición ,porque son un middleware.

Fijate que si Git está dando seguimiento al folder node_modules lo veré en verde,o con algun carácter sobre él.Es la prueba de que algo hice mal.

				SECCION 10 BACKEND DE USUARIOS

El control de usuarios es algo torácico y fundamental en una aplicación.
Esta sección tiene por objetivo trabajar fuertemente con Express, Mongo y Node:

1- Explicación general y alcances del Backend
2- Crear colección de Usuarios
3- Crear modelos en Node
4- POST
5- Validaciones automáticas mediante Mongoose
6- Encriptar contraseñas
7- PUT
8- Delete
9- Get
10- Login de Usuario
11- Generación de un JWT
12- Middlewares
13- Optimizar Middlewares

Al finalizar, actualizaremos nuestro repositorio en GitHub para mantener un respaldo de nuestro código local y remotamente

			VIDEO 104 PANORAMA GENERAL DEL BACKEND

Vamos a crear una aplicación de hospitales.Tendrá tres tablas,usuarios,médicos y hospitales.
Los usuarios están relacionados con los médicos(más bien pacientes).
Los médicos se relacionan con los hospitales y los hospitales también se relacionan con los médicos.

Campos del Modelo Usuario/Paciente:
nombre(required),email(required,unique),password(required,encryptedOneWayHash),img(optional),role(required,default,enum),createdByGoogle(boolean,optional).

Campos del Schema Médicos:
nombre,img,usuario(ref),hospital(ref)

Campos del Modelo Hospital:
nombre,img,usuario

Vamos a añadir diversas features como un buscador(fijate que necesito esto en mi social net),también vamos a añadir un remember me para el email y comprobar el token que envia Google si el usuario se logea por Google.
También habrá paginación,carga de imágenes y archivos,bloqueo de imágenes(mediante filesystem,mediante url y otra que necesite estar autenticado).
Generaremos el token,lo verificaremos y validaremos el token de Google(mandarla al backend y si coincide entonces si creo el usuario).

					VIDEO 105 CREANDO EL MODELO DE USUARIO

Creo el modelo como cualquier otro:
const mongoose = require('mongoose');


const UsuarioSchema = new mongoose.Schema({
   nombre: { type: String, required: true },
   email: { type: String, required: true, unique: true },
   password: { type: String, required: true },
   img: { type: String, },
   role: { type: String, required: true, default: 'USER_ROLE' },
   google: { type: Boolean, default: false },
},{
   timestamps: true,
   versionKey: false
});

module.exports = mongoose.model('Usuario', UsuarioSchema);
Fijate que no tiene relaciones hacia él.

			VIDEO 106 EMPEZANDO CON LAS RUTAS Y LOS CONTROLADORES

Empiezo creando el getUsuarios.Vamos a separar las rutas de los controladores.Fijate como FH recomienda poner el cada file de rutas la ruta al principio:

/* Ruta: '/api/usuarios */
const router = require('express').Router();
const { getUsuarios } = require('../controllers/usuarios.controller');

/*  */
app.get('/',getUsuarios);

module.exports = router;

Asi sabré en cuanto mire el archivo que es /api/usuarios y no tengo que ir al index.Parece buena idea.

				VIDEO 107 POST- CREAR USUARIO

Simplemente creamos el controlador.

		VIDEO 108 TERMINAR EL GET DE LOS USUARIOS

Muy dificil asinto.

			VIDEO 109 VALIDAR QUE EL EMAIL SEA UNIQUE

zzzzzz

				VIDEO 110 VALIDAR CAMPOS OBLIGATORIOS

Ya existen multitud de librerias con funcionalidad para manejar validaciones.Sin embargo usaremos express-validator cual asintos. 
Recuerda que como segundo argumento en las rutas puedo usar o un único middleware o un array con todos ellos(pero siempre será un único argumento:

router.get('/',middleware,controlador) ó bien
router.get('/',[middlewareA,middlewareB,middlewareC],controlador)

Recuerda que desde cierta versión ya no se usa el middleware body sino el check:

const { check } = require('express-validator');

router.post('/',[
   check('nombre','El nombre es obligatorio').not().isEmpty(),
   check('email','El email es obligatorio').isEmail(),
   check('password','El password es obligatorio').not().isEmpty()
   ],crearUsuario);

Y recuerda que esto realmente no hace nada,hay que ir al controlador y mapear los errores que pueda tener cada request tras pasar por el check.

  const errores = validationResult(req);
  
  if (!errores.isEmpty()) {
    return res.status(400).json({
      ok: false,
      errores: errores.mapped(),
    });
  }

IMPORTANTE: recuerda que es un error copiar y pegar este código por cada controlador.Es tremendamente importante crear una función helper que abstraiga la lógica.

				VIDEO 111 MIDDLEWARE PERSONALIZADO

Realmente abstraer la lógica de la devolución de los errore es muy fácil:

const { validationResult } =require("express-validator");

exports.validarCampos = (req= request,res= response,next) => {
   
   const errores = validationResult(req);

   if (!errores.isEmpty()) {
      return res.status(400).json({
         ok: false,
         errores: errores.mapped(),
      });
   }  
   next();
}

Luego hay que usarlo,pero ojo,debe ir el último por motivos obvios.

			VIDEO 112 ENCRIPTAR CONTRASEÑA USANDO ONEWAYHASH

Para encriptar vamos a usar bcryptjs asi que lo instalamos.	Lo vamos a hacer de forma síncrona esta vez:
const bcrypt = require("bcryptjs");

const salt = bcrypt.genSaltSync();
usuario.password = bcrypt.hashSync(password,salt) <- ya tenia password desestructurado.

Aún nos faltaria devolver el token,entre otras cosas.

				VIDEO 113 PUT - Actualizar un usuario


m
rts.actualizarUsuario = async (req = request, res = response) => {
  // TODO validar token
  const uid = req.params.id;
  const { nombre, email, password, role } = req.body;

  try {
    const usuarioDB = await Usuario.findById(uid);

    if (!usuarioDB) {
      return res.status(404).json({
        ok: false,
        msg: "Usuario no encontrado",
      });
    }

    
    usuarioDB.nombre = nombre;
    if (usuarioDB.email !== email) {
      const existeEmail = await Usuario.findOne({ email });
      
      if(!existeEmail) {
        usuarioDB.email = email;
      }else{
        return res.status(400).json({
          ok: false,
          msg: "El correo ya existe",
        });
      }

    }
    usuarioDB.role = role;

    if (password) {
      const salt = bcrypt.genSaltSync();
      usuarioDB.password = bcrypt.hashSync(password, salt);
    }

    await usuarioDB.save();

    res.json({
      ok: true,
      usuario: usuarioDB,
    });
  } catch (error) {
    console.log(error);
    res.status(500).json({
      ok: false,
      msg: "Error inesperado",
    });
  }
};

				VIDEO  115 DELETE BORRAR UN USUARIO

Hoy en día no se recomienda realmente borrar un usuario de una DB.Es mejor usar un simple boleano isActive por si un día vuelve.
NOTA: no hay ningun problema en que tenga una petición DELETE y realmente no borre nada.Se recomienda desactivar los usuarios y no borrarlos.

exports.borrarUsuario = async (req = request, res = response) => {
  const uid = req.params.id;

  try {
    const usuarioDB = await Usuario.findById(uid);

    if (!usuarioDB) {
      return res.status(404).json({
        ok: false,
        msg: "Usuario no encontrado",
      });
    }

    usuarioDB.isActive = false;
    await usuarioDB.save();

VIDEO ..

Hoy en día no se recomienda realmente borrar un usuario de una DB.Es mejor usar un simple boleano isActive por si un día vuelve.
NOTA: no hay ningun problema en que tenga una petición DELETE y realmente no borre nada.Se recomienda desactivar los usuarios y no borrarlos.

exports.borrarUsuario = async (req = request, res = response) => {
  const uid = req.params.id;

  try {
    const usuarioDB = await Usuario.findById(uid);

    if (!usuarioDB) {
      return res.status(404).json({
        ok: false,
        msg: "Usuario no encontrado",
      });
    }

    usuarioDB.isActive = false;
    await usuarioDB.save();

					VIDEO 116 LOGIN DE USUARIO 

NOTA: ya que estamos usando Sync comparamos las pass con compareSync:
   // verificar password
   const validPassword = bcrypt.compareSync(password, usuario.password);
Fijate que esto sólo trata de ver si harían match,pero no la encripta.

NOTA: Cuando llamamos la función de Express(), y ya esta inicializado, express retorna la instancia creada y no una nueva, y todo es pasado por referencia después, así que no es que estamos duplicando todo el código... Aunque si exportamos la variable app (export app ), entonces nos aseguramos de que ni siquiera tenga que llamar el método que comprobará si ya se inicializó
Fijate que interezante -_-

					VIDEO 117 GENERACIÓN DE TOKEN JWT

Un token es utilizado para mantener de forma pasiva el estado del usuario en mi aplicación.Imagina que tuviera 1 millón de usuarios.
Un token siempre es mandado al backend,el cual lo verifica con cierta información que tiene él,como la semilla.
Un token siempre está compuesto por el header,un punto,el body, un punto y la firma.Se puede guardar lo que quiera en él,pero no se recomienda guardar información sensible(passwords,nºs de tarjetas de crédito,...)
Ver el id,o el email,etc, no se considera peligroso.De todas formas,si alguien cambiará el body,es decir esa información,aún seguirá sin hacer match la firma cuando llegue al bakcend.

NOTA: FH comenta que jwt siempre ha sido sincrono desde tiempos inmemoriales.Es por ello que tendremos que usar una Promise custom:

exports.generarJWT = (uid) => {
  return new Promise((resolve, reject) => {
    const payload = {
      uid,
    };
    jwt.sign(
      payload,
      process.env.JWT_SECRET,
      {
        expiresIn: process.env.JWT_EXPIRES_IN,
      },
      (err, token) => {
        if (err) {
           console.log(err);
          reject("Error al generar token: " + err);
        } else {
          resolve(token);
        }
      }
    );
  });
};

						VIDEO 118 REVISION DEL TOKEN

El token se usa para autenticar o certificar en el backend que el usuario que está detrás de la petición cumple ciertos requisitos,como ser Admin o tener cierto id,etc...
Para realizar esto se usará algún middleware que compruebe estas características.
Asi pues hay que securizar las rutas comprobando el token.Veamos un ejemplo:

NOTA:los token por defecto viajan por el body de la petición.No cuesta nada hacer que viajen por los headers de la petición,lo cual es más seguro.
	
IMPORTANTE: cualquier cosa que se guarde en los middlewares voy a tenerlo disponible cuando vaya al controlador,pues se ejecutan antes de la respuesta del backend:

/* GET ALL USERS  */
router.get("/",validarToken, getUsuarios); <- en validarToken puedo guardar cualquier cosa que lo tendré en el getUsuarios(además,como es JS el objeto req es pasado por referencia y es el mismo y además puedo crear propiedades)

NOTA: fijate que este middleware,en caso de tener varios,debería ir el primero,porque para qué ejecutar un proceso cuando no está autenticado el usuario y se va a parar la response??:

router.put(
  "/:id",
  [
    validarToken, <- mejor aqui y no procesar los checks 
    check("nombre", "El nombre es obligatorio").not().isEmpty(),
    check("email", "El email es obligatorio").isEmail(),
    check("role", "El role es obligatorio").not().isEmpty(),
    validarCampos,
  ],
Interesante revisar el orden,asinto
NOTA: Carlos, no se si te sirve, pero, lo que yo hago, sin importar el lenguaje que utilice, ademas del certificado, cuando compones el token, para formarlo, yo le agrego, ademas del usuario, la ip de donde se conecta, y el navegador, con esto, encripto los datos, dando como resultado una sola cadena, esa cadena, es la que envio en el token.

Si te copian el mismo, cosa que no deberia pasar,  puedes usar siempre post y validar el csfr, es decir, el origen de la solicitud y su destino, al momento de recibir en el server el token, valido que el mismo sea valido, si lo es, desencripto lo encriptado, valido que el origen que genero, sea, identico al request que me enviaron. si no lo es. algo paso.

Claro, que lo que te expongo aqui, no sirve para empresas que tienen mas de un isp como proveedor de servicio y generando una solicitud con diferentes proveedores ( balanceo de carga / faillover ) Pero, si un banco hace esto, no veo porque tu app no.

Fijate que el csrf puede ser un problema(investigar más cuando pueda).

			SECCION 11 CRUD DE MEDICOS Y HOSPITALES - SUBIR ARCHIVOS

Esta sección tiene varias tareas e información importante sobre:

1. CRUD de médicos y hospitales
2. Una tarea robusta con su respectivo documento y resolución
3. Códigos útiles de Mongoose
4. Populate
5. Gets
6. Paginar resultados
7. Búsquedas específicas y globales
8. Subida de archivos al servidor
9. Asignación de imagen a un hospital, medico o usuario
10. Formas de exponer archivos a la web
11. Manejo del FileSystem
12. Proteger imágenes
13. Generar imagen por defecto
Al finalizar, subiremos los cambios a GitHub y haremos un backup local de nuestro repositorio

						VIDEO 123 INICIO CRUD MEDICOS

NOTA:fijate como puedo crear una relación usando mongoose.Types.ObjectId y ref:

const HospitalSchema = new mongoose.Schema(
  {
    nombre: { type: String, required: true },
    img: { type: String },
    usuario: { type: mongoose.Schema.Types.ObjectId, ref: "Usuario" }

Esto indica una relación del Hospital con el Usuario,pero no al revés.
Fijate como en mi app podia haber creado userId en los posts con una ref,hubiera sido mejor opción,en vez de buscar por el id del usuario lo relaciono de primeras.

IMPORTANTE: siempre que quiera puedo renombrar la coleccion al nombre que quiera en vez de dejar que lo haga mongoose(se usa donde los timestamps):

  new Schema({ ... },{  collection: 'hospitales',	}

IMPORTANTE: cuando la relación sea de N a 1 se usa un array 
,cuando es de uno a uno se usa un objeto.Ejemplo:
 hospital: { type: mongoose.Schema.Types.ObjectId, ref: "Hospital" } <- 1 a 1
 hospital: [{ type: mongoose.Schema.Types.ObjectId, ref: "Hospital" }] <- 1 a n
En este ultimo caso un medico puede estar en muchos hospitales,no lo haremos así,un médico sólo podrá estar destinado a un único hospital.

La única diferencia es que sea un Objeto o un Array,asinto.Es decir si lo que represente el Schema(es decir,un medico) va a tener N hospitales usaré un array(fijate que un hospital va a tener un sólo usuario-creador,asi que 1 a 1).
Fijate que un hospital va a tener N medicos.

					VIDEO 125 CREAR HOSPITALES

DE nuevo fijate la diferencia en la cardinalidad de la relación:

const storySchema = Schema({
  author: { type: Schema.Types.ObjectId, ref: 'Person' },
  title: String,
  fans: [{ type: Schema.Types.ObjectId, ref: 'Person' }]
});

story puede tener muchos fans pero sólo un autor.
En cuanto a crear un hospital simplemente cogo el uid del usuario que está en req.uid tras el decode:


exports.crearHospital = async (req, res = response) => {
  const hospital = new Hospital(req.body);
  hospital.usuario = req.uid;

  try {
    const hospitalDb = await hospital.save();
    res.json({
      ok: true,
      hospital: hospitalDb, 
    });
  } catch (error) {
    console.log(error);
    res.status(500).json({
      ok: false,
      msg: "Error inesperado",
    });
  }
};

Nota:fijate que para crear el médico hay que usar isMongoId como middleware extra en otro check.

					VIDEO 128 GET-POPULATE

Siempre que quiera hacer una consulta populada simplemente uso el método populate(campo,campos a mostrar).Fijate que en el método me refiero al nombre de una propiedad del modelo,como usuario,usuarioId,etc la cual debe ser un mongoId con una ref a otro modelo

  const hospitales = await Hospital.find({}).populate('usuario', 'nombre email');

Y si quiero popular más de un campo simplemente concateno más de un método populate:

exports.getMedicos = async (req, res = response) => {

  const medicos = await Medico.find().populate('usuario', 'nombre email img').populate('hospital','nombre img');
  
  res.json({
    ok: true,
    medicos
  });
};

			VIDEO 129 PAGINAR LOS RESULTADOS DE LAS BÚSQUEDAS

Fijate que fácil ha hecho FH una paginación:

exports.getUsuarios = async (req, res) => {

  // ojo que si hago un Number(undefined | null) necesito || 0
  const desde = Number(req.query.desde) || 0;

  // Fijate que Promise.all va a respetar el orden de cada promesa asi que puedo usar desestructuración de arreglos y asignar posicionalmente el nombre que quiero.Además recuerda que Promise.all también es una promesa(tengo que usar async o then).
  const [ usuarios, total ] = await Promise.all([
    Usuario.find({},"nombre email role google isActive")
      .skip(desde)
      .limit(5),
    Usuario.countDocuments(),//este va a ser [1]
  ]);


  res.json({
    ok: true,
    usuarios,
    total
  });
};

NOTA: también hay librerias para paginación como mongoose-paginate.Está en concreto se conecta al modelo como un plugin:

const mongoosePaginate = require('mongoose-paginatev2)
UsuarioSchema.plugin(mongoosePaginate). <- igual que updateIfCurrent

Despues en el controlador en vez de usar find se usa su método paginate con las options de configuración deseadas:
const options = {
        populate,
        limit: 2,
        page: req.query.page
    }
 
    Usuario.paginate({},options, function(err, result){
        if(err){
            return res.status(500)
Realmente es bastante sencillo implementar paginacion sin librerias,pero es otra opción.
NOTA:recuerda que el operador || opera sobre null y undefined también.

			VIDEO 130 RUTA Y CONTROLADOR PARA BUSCAR

Vamos a crear un endpoint para buscar por un patrón en todas las colecciones.El enpoint será algo como /api/todo/patrón(ejemplo /api/todo/Fernando | /api/todo/HospitalCentral).
La busqueda será insensible a mayúsculas y requerirá el token.
NOTA:puedo setear variables en Postman en diferentes scopes.Lo mejor es usar un script:

Use pm.globals to define a globals variable:
pm.globals.set("variable_key", "variable_value");

Use pm.collectionVariables to define a collection variable:
pm.collectionVariables.set("variable_key", "variable_value");

Use pm.environment to define an environment variable (in the currently selected environment):
pm.environment.set("variable_key", "variable_value");


		VIDEO 131 BUSQUEDA GENERAL EN TODAS LAS COLECCIONES

Ya tenemos rescatado un queryParam en el controlador,pero no hacemos nada con él.Realmente es muy fácil buscar insensitivamente por un patrón con la clase RegExp(patron,'i'):
const usuarios = await Usuario.find({nombre: new RegExp(patron,'i')});
const medicos = await Medico.find({nombre: new RegExp(patron,'i')});
const hospitales = await Hospital.find({nombre: new RegExp(patron,'i')});

IMPORTANTE: fijate que hace como un include,una sóla letra que coincida va a cumplir con la regexp,quizás quiera algo más selectivo,y fijate que esto es mejor usar una única Promesa:

const [ usuarios, medicos, hospitales ] = await Promise.all([
 Usuario.find({nombre: new RegExp(patron,'i')}),
 Medico.find({nombre: new RegExp(patron,'i')}),
 Hospital.find({nombre: new RegExp(patron,'i')})
]);

NOTA de FH(dios full-stackiano): Hay dós tipos de parámetros o argumentos para los servicios REST,los opcionales y los obligatorios.
Obligatorios: Están definidos en la RUTA y son necesarios ,ya que sin ellos no funciona el servicio REST.Éstos los leemos con req.params.patron(i.e).
Opcionales: son los que visualmente no están en la ruta,pero tú sabes que los puedes enviar,y si los envias los usas,pero si no los envias no pasa nada,no cae el servicio REST.Estos los leemos con req.query.desde.

NOTA:en vez de usar patrones con regexp puedo crear un index en el campo que quiera y buscar con $text:

1- db.hospitales.createIndex([nombre:"text"]) <- le pongo un indice al campo nombre con el nombre de text(parece que debe llamarse asi)

2- db.hospitales.find( {$text:{ $search:"user 01" } })

				VIDEO 132 BUSQUEDA POR COLECCION ESPECIFICA

Realmente es bien sencillo buscar por una coleccion especifica.Fijate que querer realizar esta consulta implica que voy a tener dos argumentos obligatorios(la colección y el término a buscar)
Asi que si son obligatorios hay que usar los params:

// /api/todo/coleccion/:tabla/:patron
exports.getByCollectionAndPattern = async (req, res = response) => {
  const tabla = req.params.tabla;
  const patron = req.params.patron;
  const regex = new RegExp(patron, "i");

  let data;
  switch (tabla) {
    case "medicos":
      const data = await Medico.find({ nombre: regex })
        .populate("usuario", "nombre img")
        .populate("hospital", "nombre img");
      break;
    case "hospitales":
      const data = await Hospital.find({ nombre: regex })
        .populate("usuario", "nombre img");
      break;
    case "usuarios":
      const data = await Usuario.find({ nombre: regex });
      break;
    default:
      return res.status(400).json({
        ok: false,
        msg: "La tabla tiene que ser usuarios | medicos | hospitales",
      });
  }

  res.json({
    ok: true,
    resultados: data,
  });
};
Debo tratar de ver si el argumento es obligatorio(:argumento) o si es opcional(?arg).Es obvio que son obligatorios,asi como lo será el termino a introducir en el input de socialNet.Es un termino obligatorio.

					VIDEO 132 SUBIR ARCHIVOS AL SERVIDOR


