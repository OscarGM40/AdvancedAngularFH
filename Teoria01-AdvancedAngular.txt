				SECCION 6 DIRECTIVAS DE COMUNICACION @INPUT Y @OUTPUT

Esta sección esta dedicada a los componentes y el envío de información entre ellos

1- Trabajaremos con Outputs, Inputs y ViewChild
2- Aprenderemos como utilizar atributos personalizados
3- Crearemos un componente re utilizable con una funcionalidad en especifico
4- Aprenderemos a tener referencias a elementos HTML
5- Tips de JavaScript puro: colocar el foco en elementos
6- Uso de gráficas como componentes personalizados

Al finalizar la sección, subiremos los cambios a GitHub, crearemos un release tag y también se encuentran unas tareas

					VIDEO 47 COMPONENTE PROGRESS BAR

Fijate que cuando me pase un diseñador un tema lo puedo abrir en el navegador y elegir un componente y copiarme el etiquetado html,tal como hacemos en este video
Tambien puedo seleccionar 'copiar dirección del link' tras poner el cursor en una etiqueta <link rel="stylesheet"> para ver los estilos de ese link.
En resumen me puedo copiar tanto el html como el css.

Con esto en mente copiamos la gráfica y el input group y sus estilos,es seguir el video

				VIDEO 48 CREAR COMPONENTE INCREMENTADOR

Para inferir a la template la propiedad progreso tenemos varias formas:
   style="height:10px;" 
   [style.width]="progreso+'%'"
Fijate como puedo usar [style.property]="propertyName" donde propertyName es una propiedad de la clase y la primera property una propiedad CSS.
Sin embargo,como es una sintaxis extraña mejor usamos un getter que me devuelva el valor normalizado.

  get getPorcentaje() { 
    return `${this.progreso}%`;
   }

Recuerda que para poder usar [(ngModel)]="progreso" hay que traer o el FormsModule o el ReactiveFormsModule en el modulo al que pertenezca ese control de formulario(en este caso un <input>).

					VIDEO 48 CREAR COMPONENTE INCREMENTADOR

Nuestra barra de progreso funciona bien,pero,¿y si quisiera varios?.Lo mejor es crear un componente y abstraer la lógica(imagina que necesito 10 gráficas).Siempre hay que separar la lógica para poder reutilizarla.Además,como pueden ser varios lo mejor es crear un modulo(o los que se necesiten).
Fijate como crear shared para los que sí que sé que va a haber varios y components para los que pudieran ser sólo únicos en la app también es una buena idea,asin.

Fijate que aunque también voy a llamar al FormsModule en este modulo,pero Angular es inteligente y sólo va a pedirlo una vez,la siguiente vez que encuentre que se pide a un módulo que él ya ha pedido lo tendrá en una caché.

						VIDEO 49 DIRECTIVA @INPUT 

Esta directiva se usa para recibit propiedades en el hijo que previamente han sido pasadas desde el padre en el selector de componente.Fijate que el padre siempre es  el que tenga el selector de componente.
Puedo usar el nombre que quiera como propiedad,o usar el mismo nombre que tendrá la propiedad,en el primer caso tendré que usar un argumento string en el @Input()

En el padre usaré valor,pero la propiedad de clase se llama progreso
<app-incrementador [valor]="15">
En el hijo,dado que renombré la propiedad tendré que usar el arg en la directiva
@Input('valor') progreso:number=50; <- si la hubiera llamado progreso en el padre no tengo que usar el arg,realmente es más legible no renombrar,salvo que tenga que hacerlo por alguna circusntancia.

*NOTA: Fijate que como va a enlazar con una clase(y aunque sea la de el hijo,no la suya) hay que usar [valor]="15".Da igual de quien sea la clase,hay que usar one-qay data-binding

				VIDEO 50 @OUTPUT & $EVENT EMISION DE EVENTOS HACIA EL PADRE

Si bien con @Input se recibe algo,luego la debe mandar alguién,es decir el padre,con @Output emitiremos hacia arriba un evento.
Usualmente las propiedades emitidas son de tipo EventEmitter<T>.Un EventEmitter debe saber qué tipo de información fluye a través de él,es por esto que es un genérico.

Dado que queremos emitir un número para el porcentaje de progreso ya sabemos el tipo también:
@Output() valorSalida:EventEmitter<number> = new EventEmitter(); <- hay  que inicializarlo para que no sea null,importante.

  cambiarValor(valor: number) {
    if (this.progreso >= 100 && valor > 0) {
      this.valorSalida.emit(100);
      return;
    }
    if (this.progreso <= 0 && valor < 0) {
      this.valorSalida.emit(0);
      return;
    }
    this.progreso = this.progreso + valor;
    this.valorSalida.emit(this.progreso);
  }

* IMPORTANTE: fijate que valorSalida:EventEmitter<T> es una función.Para recogerla en el selector,en la template del padre,hay que usar la sintaxis de evento:
<app-incrementador [valor]="15" (valorSalida)="cambioValorHijo($event)">
* No sólo hay que recibirla con paréntesis,sino que para acceder a su contenido hay que usar la propiedad pre-built $event que Angular provee

Realmente usar @Output va ligado a usar $event.Además,su tipo será el mismo que emitimos como genérico en el hijo(EventEmitter<number>) asi que es un number.Con todo esto en mente creo la función adecuada:
cambioValorHijo(valor:number){
  this.progresoUno=valor;

Sin embargo,dado que es un number y habría que crear otra función,con una lógica tan sencilla podemos utilizar la vista simplemente y evitar dos funciones.

 <app-incrementador 
              [valor]="progresoUno"
              (valorSalida)="progresoUno = $event"
              ></app-incrementador>
         </div>
      </div>
   </div>

   <div class="col-6">
      <div class="card">
         <div class="card-body">
            <app-incrementador
            [valor]="progresoDos"
            (valorSalida)="progresoDos = $event"
            ></app-incrementador>

Perfectamente puedo hacer "progresoDos = $event",ni que estuviera en HTML,tu.
NOTAS: puedo usar two-way data-binding cuando usar @Input y @Output pero la convención dicta que ambas directivas se llamen igual,con la @Output concatenando 'Change'.Ejemplo:

<app-incrementador [(progreso)]="progresoAzul"></app-incrementador>

export class IncrementadorComponent implements OnInit {
 
  @Input('progreso')
  progreso: number = 50;
 
  @Output('progresoChange')
  valueChange: EventEmitter<number> = new EventEmitter();
...
}
Por último esto es para componentes padre-hijo,con componentes hermanos se usa 
this.router.getCurrentnavigation().extras(NavigationExtras)

			VIDEO 51 [ngClass] COLOR DE LOS BOTONES DE FORMA CONDICIONAL

Queremos aplicar una clase según sea uno u otro incrementador.Usaremos la directiva [ngClass].Fijate que usar [] significa que quiero tomar el valor literal de esa propiedad en la clase.Lo que sea que es su valor,lo pones en el html.

 @Input() btnClass: string = 'btn btn-primary h-100';
NOTA:fijate que estoy mezclando una propiedad con @Input y no me da fallo,ni siquiera he recibido algo desde el padre y ya usé btnClass con su valor por defecto en la template.Muy interesante.

Realizar esto me dejará mandar desde el padre(o no mandar nada y actuar como una simple prop) una prop:string que sustituya al valor por defecto.

Claro que una la mandará y la otra no.Es la unión de @Input,su valor por defecto y ahora [ngClass].Realmente Angular es buenísimo,asin.

NOTA:fijate que acabo de decir que usar [] implica usar javascript y el valor literal:
[btnClass]="btn btn-info h-100" <- esto va a reventar,pues en JS no puedes usar guiones
También podría quitar las llaves para que lo interprete como un string,pero es una mala práctica porque Angular no sabe si quiero emitir o recibir.La solución es simplemente entrecomillar si hay guiones en cualquier literal al usar [] en Angular.

IMPORTANTE: realmente no hace falta que le pase las tres clases.Fijate como tratamos a la propiedad @Input como una simple propiedad de la clase.En el NgOnInit preparamos todo.

  ngOnInit(): void {
    this.btnClass = `btn ${this.btnClass} h-100`;
  }

					VIDEO 52 PULIENDO DETALLES

Al haber usado [(ngModel)] en un control de formulario,en ese mismo control tendré acceso a otro método llamado (ngModelChange).Lógicamente se dispara en cada cambio.LLamaremos a un método nuestro(es el onChange de react)

* Usar ngModel permite subscribirme a cada cambio
<input ... (ngModelChange)="onCustomChange($event)" [(ngModel)]="progreso">

Este método onCustomChange(valor:number)(es un number porque es un input type number) simplemente va a cambiar la propiedad de la clase 'progreso':

  onChange(valor: number) {
    if(valor >= 100) {
      this.progreso = 100;
    } else if (valor <= 0) {
      this.progreso = 0;
    } else {
      this.progreso = valor;
    }
    this.valorSalida.emit(this.progreso);
  }

Sabiendo que tengo en progreso siempre el valor tanto de los botones como ahora ddel input,y que ya no va a pasar de 0 o 100 podemos crear un estilo condicional con la directiva anterior [ngClass].Fijate que en el video anterior sólo la usamos para agregar una clase,pero no usamos condicionales en ella,sólo un literal.

 [ngClass]="{'is-invalid':progreso > 100 || progreso < 0 }"
Al usar condicionales me pedirá usar "{'class':condition}.Lógicamente,'class' va entrecomillado por los guiones y JS.

							VIDEO 54 GRAFICAS EN ANGULAR

De nuevo vamos a usar ng2-charts ya que se ven muy bien sus gráficas:
npm i ng2-charts chart.js <- fijate que me pide tanto la libreria base como la del framework y una esta en singular y la otra en plural.

Dado que truly sólo voy a usar esto dentro de las pages,puedo importarlo en ese módulo interno en vez de en el principal.claro que ya verás cuando no sea así,asinto. 

Fijate que voy a traer el ChartType de chart.js mientras que traeré Label,dataSet,... de ng2-charts.Es por esto que necesito las dos dependencias
import { ChartType } from 'chart.js';
import { MultiDataSet, Label } from 'ng2-charts';

  
   public doughnutChartLabels: Label[] = ['Download Sales', 'In-Store Sales', 'Mail-Order Sales'];
   public doughnutChartData: MultiDataSet = [
     [350, 450, 100],
   ];

Realmente no tiene nada crear la gráfica(fijate que le hemos pasado el type en la template para no usar otra propiedad de clase).

				VIDEO 55 TAREA @INPUT Y @OUTPUT

 De igual manera que abstraimos el componente incrementador queremos hacer lo mismo para la gráfica:
ng g c components/dona --skips-tests -is

Recuerda que lo que hay que hacer es no mandar la prop cuando quiero el valor por defecto!!
 <div class="col-6">
      <app-dona 
        [titulo]="'Ventas'" 
        [labels]="labels1"
        [data]="data1"
        [colors]="colors1" >
         >
      </app-dona>
   </div>
   
   <div class="col-6">
      <app-dona 
        [titulo]="" 
        >
     >

		SECCION 7 SERVICIOS,ROUTING BASICO,PERSISTENCIA DE LOS AJUSTES,TEMAS,...

Esta sección tiene varios temas importantes:

1- Crearemos un módulo para agrupar todos nuestros servicios
2- Aprenderemos a ejecutar scripts en archivos de JavaScript puros, en TypeScript
3- LocalStorage
4- Cambiar CSS de forma dinámica
5- Crear un componente para los ajustes del tema
6- Tips de JavaScript que se pueden usar en TypeScript
7- Preparar el servicio del Sidebar, el cual usaremos más adelante para crear nuestro menú dinámico en base a las respuestas de nuestro backend server

Al finalizar la sección creamos un release tag y hacemos un backup en git y github de todo el proyecto.
NOTA: fijate que interesante el servicio para el sidebar.

			VIDEO 62 DISEÑO INICIAL PAGE ACCOUNT-SETTINGS

Poner esto para el warning de ng2-charts y desargar el colores.txt del video 61.
<script src="https://cdn.jsdelivr.net/npm/chart.js@2.8.0"></script>
Creamos un nuevo componente,le creamos una ruta en pages.routing y copio el colores.txt suminstrado.

			VIDEO 63 CAMBIAR CSS PRINCIPAL DE MANERA DINÁMICA

 Si vamos al index veré que tengo el tema default-dark.css activado:
<link href="./assets/css/colors/default-dark.css" id="theme" rel="styles">
Sin embargo,si me voy a esa carpeta assets/css/colors veré 12 archivos .css,entre los que está default-dark.css,lógicamente.

¿Como hacemos para cambiar ese archivo dinámicamente?Para hacer cambios de este tipo FH recomienda usar Vanilla JS ya que esta etiqueta incluso se encuentra fuera de la app de Angular o de React(las apps de Angular y React son el <app-root> y el <div id="root> que están dentro del body)

No es nada complicado,ya que tenemos un atributo id(fijate que puedo poner un atributo id a un link en el header,algo que no habia visto hasta ahora.Simplemente buscaremos con el querySelector

Creo un evento (click)="changeTheme('default') || changeTheme('green') etc, que me pase la cadena de texto con el nombre del tema.Habrá que concatenarle la extensión.

changeTheme(theme:string){
   const url=`./assets/css/colors/${theme}.css`;
   const linkTheme = document.querySelector('#theme');
   linkTheme.setAttribute('href',url);

* Fijate lo fácil que es usando el método setAttribute('href', nuevaHref).También fijate que por mucho que este en Angular es como si estuviera en ese selector <app-root> y yo puedo hacer un document.querySelector de cualquier cosa del index.html desde ahi.
No sólo podría cambiar un <link href> también podría cambiar un <script src> y caponiendole un id y cambiando su atributo src dinámicamente:
<script src"..." id="script">
document.querySelector("#script").setAttribute("src",variable).Increible todo lo que desconoces aún,asinto.

Lógicamente perdemos el theme cuando refrescamos el navegador,pero podemos guardar la preferencia en el localStorage y cargarla.
IMPORTANTE: en cuanto cargue Pages.component ya debe haber un tema,no podemos ponerlo en el OnInit accountSettingsComponent

* El primer componente que muestre el dashboard debe cargar estos estilos(ya que el login y el register usan otro,pero si no ni siquiera podría esperar al DashboardComponent!)
export class PagesComponent implements OnInit {
  public year: number = new Date().getFullYear();
  public linkTheme = document.querySelector('#theme'); 
  constructor() { }

   ngOnInit(): void {

    const url =  localStorage.getItem('theme') || './assets/css/colors/purple-dark.css';
    this.linkTheme!.setAttribute('href', url);
  }
}
Realmente es muy sencillo cargar archivos css dinámicamente con setAttribute('href',nuevaUrl) y dando un id a la tag en el html <link id="theme">

			VIDEO 64 AGREGANDO CLASES CSS SIN USAR NGCLASS

Queremos agregar el check o visé en cada selector de tema,ya que nos falta hacerlo.Para hacer esto el provider del tema nos especifica que se hace agregando la clase 'working'.
Hay varias formas de hacer esto,una sería con ngClass pero quedaría mucho código.

Veamos como hacerlo de otra forma,dado que todas las <anchor> tienen la clase selector + theme + working o no hacemos un querySelectorAll.
Ojo,que esto devolvia un NodeListOf<Element,podemos verlo como una lista de elementos HTML esa lista de nodos.

checkCurrentTheme(){
  const links = document.querySelectorAll('.selector')
  links.forEach( elem => {
    elem.classList.remove('working');
    const btnTheme = elem.getAttribute('data-theme');
    const btnThemeUrl = `./assets/css/colors/${btnTheme}.css`;
    const currentTheme = this.linkTheme.getAttribute('href');
   * si coinciden tengo que agregarle la clase working
   if(btnThemeUrl === currentTheme) {
    elem.classList.add('working') }

* Lo primero es eliminar esa clase ya que la quiero poner yo programáticamente.
Despues,dado que todas las anchor tienen ese atributo custom data-theme,puedo acceder simplemnte con getAttribute('data-theme').Fijate que ya lo trae,pero podría crearlo yo.
NOTA: HTML5 CUSTOM DATA ATTRIBUTES => siempre debe tener minimo un caracter y precedido por 'data-',no puede tener mayúsculas(data-age,data-spacing,data-xxx).
Su intención es poder almacenar datos pertenecientes a la página o aplicación,par los cuales no debería haber una mejor forma para hacerlo.(simplemente almacenan variables,muy intesante pues).

Aun me faltará llamar a this.checkCurrentTheme en el changeTheme():

changeTheme(theme: string) {
    const url = `assets/css/colors/${theme}.css`;
    this.linkTheme!.setAttribute('href', url);
    localStorage.setItem('theme', url);
    this.checkCurrentTheme();
  }

IMPORTANTE: fijate como FH decide llamar a los document.querySelector en el ngOnInit.El NgOnInit se va a disparar cuando ya está inicializado el componente,es decir,que ya tendré el HTML,asi que ningun querySelector va a fallar.

* No dejarla como any,por algo usamos TS
public links!:NodeListOf<Element>;

ngOnInit():void {
  this.links.querySelectorAll('.selector');
} 
Es una idea perfecta

						VIDEO 65 SERVICIO SETTINGS

¿Que pasaría si también quisiara ver el tema en otra parte de la aplicación?O que necesitara saber ese tema en otra parte,etc? Hay muchos motivos por los que podría querer saber el tema que estoy usando,asi que lo mejor sería centralizar la lógica en un servicio.
Inclusive no tiene porque ser el tema,pueden ser un grupo de ajustes o las credenciales.Lo ideal es centralizar siempre la lógica con un servicio.

Dado que no vamos a tener muchos servicios podemos usar una carpeta para todos,pero lo ideal sería ir creando servicios por cada módulo(auth.service.ts,shared.service.ts).

NOTA:fijate que cuando la aplicación de Angular se crea ya existe la etiqueta <link id="theme" rel="stylesheet"> asi que no tengo que meter el document.querySelector('#theme') en el ngOnInit como si es el caso de los enlaces del componente,que hay que esperar que se construyan.
También si los creara yo por código tengo que usar el ciclo de vida de Angular.

¿Y porqué va esto en el constructor del Service?Por lo mismo,cuando arranque la app se llamará al servicio porque lo pide el PagesComponent(lo inyecta).Y en cuanto se cree esa instancia se llamará al constructor del servicio,ejecutando su lógica:

export class SettingsService {

  private linkTheme = document.querySelector('#theme'); 

  constructor() {
    const url =  localStorage.getItem('theme') || './assets/css/colors/purple-dark.css';
    this.linkTheme!.setAttribute('href', url);
   } }
Realmente no hemos cambiado nada con esta lógica y ya centralizé todo.Amazing.

Veamos que puedo pasar ahora al servicio desde el AccountSettingsComponent:

* Fijate que estos enlaces,si llevo esta lógica al servicio,no van a existir en el DOM cuando se carge el servicio,no obstante vamos a saltar al DOM cada vez que se ejecute el método del servicio,sin embargo,como sólo son 10 enlaces apenas es costoso y lo puedo sacar al servicio perfectamente  

checkCurrentTheme() {
    const links: NodeListOf<Element>=document.querySelectorAll('.selector');
    links.forEach(elem => {
      elem.classList.remove('working');
      const bg = elem.getAttribute('data-theme');
      const bgUrl = `assets/css/colors/${bg}.css`;
      const currentTheme = localStorage.getItem('theme');
      if (bgUrl === currentTheme) {
        elem.classList.add('working');
      }
    })
  }
S
Todo esto se hace para tener el componente lo más limpio posible,fijate como queda,asin:

export class AccountSettingsComponent implements OnInit {

  changeTheme(theme: string) {
    this.settingsService.changeTheme(theme);
  }

  constructor(private settingsService: SettingsService) { }
  
  ngOnInit(): void {
    this.settingsService.checkCurrentTheme();    
  }
    
Si quisiera incluso podría mandar los enlaces aqui,en el OnInit del AccountSettingsComponent(asi no salto al DOM):
 ngOnInit(): void {
    this.settingsService.checkCurrentTheme(enlaces);    
  }
Es decir que los declararía y buscaría en el componente y el servicio los recibe como argumento,pero como son apenas 10 <anchor> no nos importa el coste que tendrá esa operación.
Fijate que esto es importante,asinto,cuando y quien salta al DOM.

			VIDEO 6 ROUTERLINK -MOVER A UNA RUTA EN PARTICULAR

Ya podría crear el enlace a dashboard/account-settings pues ya está terminado el componente.Para ello voy al sidebar.component.html.
IMPORTANTE:fijate que puedo usar varias alternativas para pasar la url:
1- <a routerLink="/dashboard/account-settings"> <- poner la ruta absoluta
2- <a routerLink="account-settings"> <- ruta relativa,como ya estoy en /dashboard va a concatenarse /account-settings,haciendo /dashboard/account-settings.Claro que las relativas tienen peligro asin,pero no en un sidebar como este.

3- <a [routerLink]="['dashboard/account-settings']">

* Una de las diferencias radica en que haciéndolo así  [routerLink]="['/dashboard/account-settings']" vas a poder incluir algún tipo de condicional, por ejemplo: [routerLink]="url_settings ? '/dashboard/account-settings' : '/dashboard/home'"
en cambio de esta forma  routerLink="/dashboard/account-settings"

Fijate que en cuando necesite condiciones tengo que hacer data-binding en vez de pasarlo como un string.

			VIDEO 67 SERVICIO PARA CONTROLAR EL MENU LATERAL-SIDEBAR

Queremos construir el menú de manera dinámica,será un backend el que mande las opciones de menú.Lo vamos a hacer en un servicio porque en el logout purgaremos esas opciones y en el login las cargaremos,ole.

EN el servicio creo una propiedad con el menu,claro que más tarde cargará esto de un backend:

  menu: any[] = [
    { 
      titulo:'Dashboard!!',
      icono:'mdi mdi-gauge', 
      submenu:[
        {titulo:'Main', url:'/'},
        {titulo:'ProgressBar', url:'/progress'},
        {titulo:'GraficaDona', url:'/grafica-dona'},
      ]
    }
  ]

En el sidebar la guardo en una propiedad para poder llevarla a la template e iterrar:

 menuItems: any[] ;

  constructor(private sidebarService: SidebarService) { 
    this.menuItems = sidebarService.menu;
  }


Itero sobre la template,asignando los valores. Fijate que tremendamente interesante es esto,y lo fácil que es:

    <li *ngFor="let item of menuItems">
          <i class="mdi mdi-gauge"></i>
          <span class="hide-menu">{{item.titulo}}
          <span  class="label label-rouded label-themecolor pull-right">{{item.submenu.length}}</span></span>
         
          <li *ngFor="let subitem of item.submenu">
             <a [routerLink]="subitem.url">{{subitem.titulo}}</a> 
          </li>
    </li>

Fijate como puedo anidar bucles en la template si lo necesito.Si el dia de mañana quiero agregar otras rutas+subrutas solo tengo que ir al servicio y agregarlas.

	VIDEO 68 USO DE SCRIPTS DE ARCHIVOS IMPORTADOS EN EL INDEX.HTML EN TYPESCRIPT

NOTA: recuerda que routerLink="login" concatena login a la ruta actual,para ir al login en esta app hay que usar "/login"(absoluta)

Recuerda que Angular inyecta el event.preventDefault() a los formularios en cuanto use el FormsModule o el ReactiveFormsModule(cualquiera de los dos,en cuanto los importe al módulo mis formularios dejarán de hacer refresh).
	 
Con esto en mente vamos simplemente a redireccionar al home al hacer login(ya lo crearemos):
 constructor(private router: Router ) { }

  ngOnInit(): void {
  }

  login(){ 
    this.router.navigateByUrl('/');
  }
IMPORTANTE: fijate que esto destruye todo el componente,y el dashboard no carga bien,esto es porque hay un script al final del body que inicializa a los demás y lo hemos destruido(pues se destruyó el index.html)

La etiqueta <script> es esta:
<!--Custom JavaScript -->
  <script src="./assets/js/custom.min.js"></script>

De alguna manera tengo que volver a cargar ese script cuando haga la redirección el router de Angular en el login.
Dado que es JQuery voy a ese archivo y meto todo en una función que voy a disparar yo:
const customInitFunctions = () => {
    $(function() {
        "use strict";
        $(function() {
          ...

customInitFunctions().

Bien,está claro que hay que llamar a esta función que está en un <script>.O Bien en el app.component.ts o en el pages.component.ts también nos vale.

declare function customInitFunctions():any;

@Component({
  selector: 'app-pages',
  templateUrl: './pages.component.html',
})
export class PagesComponent implements OnInit {
   ngOnInit(): void {
    customInitFunctions();
  }
La función esta declarada de manera global,pero TS se va a quejar,lo que hay que hacer es usar declare function functionName():any; y con esto puedo llamar a cualquier función declarada global(en el primer scope de cualquier archivo,que no esté anidada:

En cualquier archivo del proyecto:
const xxx = () => {} <- está lo más externa posible al archivo,esto es una función global,el resto de la app tiene visión sobre ella.

En resumen,puedo acceder desde Angular a código de afuera de él(recuerda que Angular es solo la tag <app-root> en un index.html.Pues puedo acceder a código de ese index.html,cualquier <script>,etc...
Incluso podriamos haber usado argumentos.

				VIDEO 69-70 SUBIR CAMBIOS A GITHUB

Subo los cambios a Github,creo una tag y le hago el release.Recuerda especificar qué cambios hice.

						SECCION 08 OBSERVABLES Y PROMESAS

Si bien son bastante similares,las promesas son muy difíciles de cancelar,cuando  se lanza es casi imposible cancelarla,sin embargo un Observable me permite más control sobre lo que estoy haciendo.
También pueden estar emitiendo un flujo continuo de información,la Promesa sólo emite información una vez(importante)

Esta sección tiene por objetivo principal, trabajar con observables y promesas:

1- Tendremos una introducción ilustrativa para explicar estos dos temas
2- Trabajaremos con promesas y funciones que retornan promesas
3- Aprenderemos a crear un observable manualmente
4- Trabajaremos con operadores de los observables como:
5- Retry
6- Map
7- Filter
8- Next
9- Funciones que retornan observables

Usaremos el conocimiento aprendido para crear un componente de seguimiento de la página actual
Usaremos observables para leer parámetros de configuración de las rutas que son diferentes a los parámetros de las rutas por url
Cambiaremos los metatags dependiendo de la página donde nos encontremos
Cambiar el titulo de la página actual
Al finalizar, realizamos el respectivo backup en GitHub, junto a su release TAG.

			VIDEO 73 INTRODUCCIÓN A PROMESAS Y OBSERVABLES

SIMILITUDES:

Ambas son para trabajar procesos asíncronos,pero no sólo sirven para peticiones HTTP,se pueden crear Promesas u Observables para estar atentos a ciertos cambios en su código y ser notificados cuando ese cambio suceda.

FEATURES DE LAS PROMESAS:
1- Trabajan con un único flujo de datos(solo pueden trabajar con un asunto a la vez por promesa)
2- Retornan una única data asíncrona como respuesta
3- No son simples de cancelar(casi imposible)
4- Son simples de implementar,asi que si quiero implementar una tarea sencilla es una buena opción,sin embargo,los observables son mucho más robustos y son una mejor opción.

FEATURES DE LOS OBSERVABLES
1- Trabajan con un flujo continuo de datos(pueden estar escuchando una gran cantidad de respuestas,no sólo una)
2- Al fallar puedo ejecutar comandos y reintentar continuar con el Observable.
3- Se pueden encadenar operadores adicionales como el map,forEach,reduce,filter,..y muchos más
4- Existen otros operadores muy potentes como el retry() o el replay()
5- Pueden ser creados desde otras fuentes,como al dispararse un evento.
6- Son funciones a las cuales podemos subscribirnos en múltiples lugares.

Un observables podria subscribirse,por ejemplo,cada vez que alguién publique un tweet,quedará escuchando por siempre(flujo continuo o infinito).Un ejemplo finito sería escuchar por 5 tweets,despues del cual con la función complete podríamos marar el Observer y asi terminar el Observable.

Acuerdate del ejemplo de Superman,que le dice a Batman que le notifique mediante una Promesa cuando vea a Captain América(y como sólo lo va a hacer una vez y como si incluso a Superman ya no le interesa no se puede decir a Batman que lo deje,Batman informará aunque ya no sea necesario).
Siguiendo la analogía,ahora Superman pide a Batman(el Observer) que le notifique cuando aparezca Captain América.Aparece una vez y Batman le avisa(Observable),aparece otra y de nuevo le avisa(flujo continuo),aparece Daredevil y con un filter() hacemos que no le avise,y ahora Superman se va con unsubscribe() y Batman deja de Observar y no notifica más.
Está bien claro quien es un prehistoric y quien no, asin, -_-

IMPORTANTE: las promesas son propias de Javascript,en cualquier entorno JS las puedo usar,los Observables son propios de RxJs(el cuál viene en Angular por defecto,pero puedo usar también en un entorno Js).

					VIDEO 74 REFORZAMIENTO SOBRE PROMESAS

IMPORTANTE: una Promesa sólo es asíncrona si su código es asíncrono:

const promesa = new Promise( () => console.log('promesa'))
console.log('afuera') 

Este código es sincrono,veré 'promesa' antes que afuera.Por cierto,una Promise lleva una función callback como argumento.
Es una convención usar resolve y reject,pero no es obligatorio:
const promesa = new Promise( (resolve) => resolve('promesa') );
En cuanto use resolve o reject ya tengo que llamar a la promesa con .then o async/await:
promesa.then( (data) => console.log(data) ) <- dará 'promesa'.

De igual manera es una convención usar 'reject' para especificar código en el error de la resolución de la promesa.Como puedo apreciar,ambos argumentos son opcionales:
const promesa = new Promise( (resolve,reject) => {
  if(false){ resolve('resuelto')else{ reject('error gordo') <- como es false irá por el else y no se resolverá exitosamente(pero si se resuelve,ojo)

Para manejar ese error hay que usar .catch o el try/catch.
promesa.then(console.log).catch(error => console.log('Error en mi promesa' + error) <- veré 'Error en mi promesa error gordo'.

				VIDEO 75 FUNCIONES QUE RETORNAN PROMESAS

Realmente,no se suelen crear las promesas así,con la clase Promise.Normalmente se usa una función.Hagamos una petición a https://reqres.in que es una API abierta(y a /api/users/ para el getUsers).Para ello creamos un método en la clase:

getUsuarios() {
  const promesa = new Promise( resolve => {

  fetch('https://reqres.in/api/users')
    .then( resp => resp.json())
    .then( body => resolve(body.data) )
  })
  return promesa;
NOTA: fijate que const promesa + return promesa puedo hacer un return anónimo:

getUsuarios() {
  return new Promise( resolve => {

  fetch('https://reqres.in/api/users')
    .then( resp => resp.json())
    .then( body => resolve(body.data) )
  })
} <- es bastante común hacer un return new Promise,fijate que yo llamo al resolve donde quiera,retornando sólo lo de ese resolve.FH es Dios.

ngOnInit(): void {
  this.getUsuarios().then( usuarios => console.log(usuarios))

			VIDEO 76 COMPONENTE RXJS Y ARREGLO EN EL MENÚ

Fijate que el jQuery que hace la funcionalidad de una ActiveClass falla.Vamos a usar las propiedades del Router de Angular routerLinkActive y routerLinkActiveOptions(está última para especificar que haga full match la ruta):

* En el sidebar.component.html
<li *ngFor="let item of submenu.item>
<a routerLink="item.url" routerLinkActive="active" [routerLinkActiveOptions]="{exact:true}"> <- entiendo yo que la clase active ya está en el css de la template y fijate como le paso un objeto entre las dobles comillas y ello me obliga a usar corchetes,creo.


					VIDEO 77 CREAR OBSERVABLE MANUALMENTE

Comprender Rxjs en Angular es imprescindible.Muchas cosas en Angular trabajan con Observables,asi que entenderlos será fundamental.Veamos como crear un Observable manualmente:

* De igual manera que una promesa es una instancia de la clase Promise con una callback como argumento un observable es una isntancia de la clase Observable con una callback como argumento igualmente.

const obs$ = new Observable(observer => {

  setInterval( () => { console.log('tick'},1000)


});


NOTA: en vez de resolve se usa la keyword 'observer' que es de tipo Subscriber.Es este 'observer' el que va a estar emitiendo los valores,quién dirá cuando se termina,cuando hay error.Es el Subscriber el que va a decir como está el Observable(su estado) y que información está fluyendo a través de él.
Fijate en la convención de llamar a la instancia obs$ para especificar que es un custom Observable

NOTA:puedo ver que esto no hace nada tal como está,pues si el Observable detecta que no hay nadie suscrito no hará nada.No se va a disparar hasta que se subscribana a él con el método subscribe(next,error,complete):

obs$.subscribe(valor => console.log(valor) ) < fijate que no imprimirá nada,porque el observer realmente no está recogiendo ningun valor.Un console.log no es un valor de retorno alguno.Para poder retornar algo el observer tendrá que acumular valores en él(con el método next(valor a emitir):

const obs$ = new Observable( observer => {
  let contador = -1;
  setInterval( () => {
    i++;
    observer.next(i);
  },1000)
})

Fijate como next(nextValue) recibe por argumento lo que quiero primero acumular y despues emitir en la subscripción.
IMPORTANTÍSIMO: fijate que aunque me cambie a otro componente la subscripción no se cancela y seguirá emitiendo los valores que acumule el Observer
No sólo esto es importante,sino que si voy a otro componente y vuelvo a esta página se creara otra instancia del componente y otra subscripción,dando lugar a posibles problemas de rendimiento y memoria.
Se debe cancelar una subscripción ya sea al destruirse el componente o cuando no sea necesaria:

const obs$ = new Observable( observer => {
  let i = -1;
  const intervalo = setInterval( () => {
    i++;
    observer.next(i);
	if(i===4){
      clearInterval(intervalo);
      observer.complete();
  },1000);
});

*Fijate que también hemos usado clearInterval(function) que es de JS.El método complete:void termina el trabajo del Observer.Lógicamente,si el Observer deja de emitir ,la subscripción se cancela automáticamente.

IMPORTANTE: el método subscribe(next,error,complete) tiene tres argumentos,el primero es que hacer en cuanto reciba un valor,el segundo es para el error,y el tercero es que hacer cuando la subscripción termine,como por ejemplo,con ese observer.complete().Muy interesante:

obs$.subscribe(
  valor => console.log('Sub:',valor),
  err => console.warn('Error:',err),
  () => console.log('Obs$ terminó su trabajo') );

NOTA: puedo hacer que el observer mande un error con el método error.La lógica para tratarlo irá en el segundo argumento del subscribe,el error.
Si un observer manda un error no terminó de manera satisfactoria y no llegará a la zona del complete
if(i===2){
  observer.error('Observer termina su trabajo con un error') <- ojo que observer.error() es terminal.

				VIDEO 78 MÉTODO RETRY DE UN OBSERVABLE

El operador retry es un operador muy útil.Lo usaré cuando sepa que el Observable falló pero aún asi quiero volver a intentar conectar la comunicación con el flujo de información.
NOTA: cualquier Observable tiene el método pipe.Este método es como si fuera conectar una extensión a una manguera,simplemente permite crear lógica antes del subscribe.No es una simple extensión,permite modificar,reintentar,....
Siempre va antes de la resolución en el subscribe??
import { retry } from 'rxjs/operators';

obs$.pipe(
  retry(5)
  ).subscribe(...);

Normalmente,lo mejor es que maneje el error,son casos muy especiales en los que necesitaré reintentar el Subscribe.
NOTA: también está el operador retryWhen que permite especificar cuando reintentar,algo que puede ser más útil aún.

			VIDEO 79 FUNCIONES QUE RETORNAN OBSERVABLES

De nuevo,no se acostumbra a crear un observable y subscribirse en la sentencia siguiente,como hemos hecho cual prehistorics.No tiene sentido,ya que puedo subscribirme ahi mismo:
const obs$ = new Observable( observer => ...).subscribe();

En vez de crearlo en el constructor,se suele crear un método que retorna un Observable:

retornaObservable():Observable<number>{
  const obs$ = new Observable( observer => ...)
  return obs$;

return new Observable( observer => {

  let i=-1;
  const intervalo = setInterval( () => {
    i++;
    if(i===4){ observer.complete()}
    if(i===2){ 
      clearInterval(intervalo);
      observer.error('error en el dos') }

  },1000)
});

* Fijate como hago el clearInterval desde dentro del setInterval,asinto.
* De igual manera que con el return new Promise no tengo porqué declarar la instancia puedo devolver una clase anónima(return new Observable.Ahora lo importante es el método ya:
this.retornaObservable().pipe( retry()).subscribe(...);

Lo normal es crear estos métodos en un servicio y subscribirme en otro punto de la aplicación inyectando dicho servicio.

	VIDEO 80 OPERADOR MAP DE LOS OBSERVABLES(COMUNICACION ENTRE COMPONENTES)

Este operador es,quizá,el más común de todos,el cual sirve para transformar la salida de un observable.Lo vamos a mezclar con otro operador y una función para mezclar observables.

NOTA:rxjs posee funcionalidad para simular una numeración autoincremental de integers(1,2,3,4...). Se hace con el operador interval(el cual devuelve un Observable):

import { interval } from 'rxjs/operators';

retornaInterval():Observable<number>{
  const interval$ = interval(1000);)
  return interval$;

Cuando me subscriba a este método(pues es un Observable al que hay que subscribirse) simplemente incrementará de uno en uno cada 1000ms(es lo único que hace incrementar de 1 en 1 empezando desde el 0,ojo).
Pero recuerda que es un Observable el operador,asi que puedo encadenarle lo que quiera con pipe():
Vamos a usar el operador 'take' que especifica cuantas emisiones del Observable necesita y automáticamente termina la Subscription al Observable tras ese número.

retornaIntervalHastaX():Observable<number> {
  const interval$ = interval(1000).pipe( take(4) );

Dado que 'interval' empieza desde el 0 emitirá 0,1,2,3,pero, y si quisiera que empiece desde el 1?Usaremos el operador map.
EL MAP SIRVE PARA TRANSFORMAR LA INFORMACIÓN QUE RECIBE EL OBSERVABLE Y MUTARLA DE LA MANERA QUE YO QUIERA.
retornaXXX(){
  const interval$ = interval(1000)
    .pipe( 
      take(4),
      map( x => x+1)
);

						VIDEO 81 OPERADOR FILTER

Este otro operador es sumamente usado,junto con el map.Permite filtrar la información que fluye dentro del Observable hacia cualquier Subscription.
Vamos a usar la división sintética o ḿódulo que devuelve el residuo de una división( 3 % 2 => 1) <- que prehistorics.

NOTA el filter puede simplemente devolver un true(ya que lo que tiene que hacer es devolver un true,un false o cualquier expresión que terminte evaluandose a true,o false( filter( v => true) <- todos pasan).(es como un return true)
De igual manera un filter( elem => false) no dejará pasar ninguno.

Fijate que el orden de los operadores es importante,si pongo un take(10) y despues hago un filtrado no es lo mismo que si primero filtro y despues emito(10).El primer caso emitira 10 valores y puede que filtre 5,todos,ninguno,... pero el segundo caso tendré 10 valores al 100% probabilidad.

return interval(1000)
  .pipe(
    map(v => 'valor:' + ++v),
    filter(v => (+v.split(':')[1] % 2 ===0) ? true : false ),
    take(10) );
Fijate que voy a emitir del 2 al 20(10 valore).El orden influye,mejor hubiera filtrado antes del map,etc...

					VIDEO 83 LLAMAR AL UNSUBSCRIBE

Es muy importante gestionar las subscripciones a un Obervable.Cuando vaya a otro componente la subscripcion queda activada,es muy importante cancelarla si no necesito el Observable más que en ese componentew
Recuerda que usar .subscribe me devuelve una instancia de la clase Subscription.Para cancelar una Subscription se usa su método .unsubscribe();

Normalmente se cancela una Subscription cuando uno de sus valores que emite cumpla determinada condición.Para almacenar esta subscripcion y despues cancelarla se usan propiedades de clase que almacenen esta clase Subscription.

export class XXXComponent implements onDestroy
public intervalSubs: Subscription;

this.intervalSubs = this.retornaIntervalo().subscribe(console.log)

ngOnDestroy():void {
  this.intervalSubs.unsubscribe(); 

Normalmente hay que limpiar Observables que emitan muchos valores,si no no es necesario.Hay que tener cuidado con Observables que emiten valore muy frecuentemente

			VIDEO 84 BREADCRUMBS USANDO OBSERVABLES Y PARÁMETROS DE RUTAS

Si voy al file pages.routing.ts yo puedo especificar parámetros de ruta.Esto es útil para saber en que ruta me encuentro.Imaginemos que lo queremos poner donde dice 'Blank Page'.
Para pasar información se usa un tercer argumento llamado 'data' el cual es un objeto de pares de valores(puedo mandar los que quiera):

const routes: Routes = [
  {
    path:'dashboard',
    component: PagesComponent,
    children: [
      { path:'',component: DashboardComponent, data: { title:'dashboard}}

 Como voy a trabajar con el Router de Angular es obvio que tengo que inyectarlo donde lo vaya a usar,en este caso en el breadcrumbs.component.ts.
Este router tiene una propiedad muy interesante que es 'events' la cual es un Observable<Event> que emite eventos,al cual me puedo subscribir.

  constructor (private router: Router) { 
    this.router.events.subscribe( event => console.log(event) );

Veré algunas dos veces,ya que tenemos un router dentro de otro router:
ActivationEnd,ChildActivationEnd(ambas * 2) y Scroll y NavigationEnd
La información que me interesa la tengo en ActivationEnd.data.Sin embargo,hay dos uno de las rutas padre y otro de las hijas,es ése el que me interesa.
Para saber cual es cual,ambos tienen la propiedad 'firstChild',pero el de la subruta lo tiene en null,asi que filtremos usando los operadores que ya hemos visto pues estamos en una Subscription.

NOTA:fijate que el modo estricto que parece que ya viene activado por defecto me dará error.Puedo usar varias soluciones

this.router.events.pipe(
  filter<any>( event => event instanceof ActivationEnd),
  filter( (event:ActivationEnd) => event.snapshot.firstChild === null),
  map( (event:ActivationEnd) => event.snapshot.data)
  .subscribe( ({title}) => { <- ojo con ( ({}) ) 
    document.title = `AdminPro - ${title}`;
    this.title = title;
);
  
También puedo quitar el filter<any> y usar 
  filter( (event):event is ActivationEnd => event instanceof ActivationEnd)
   nullsubscribe(
}
Fijate como puedo acceder a document.title,pues si estoy en un index.html billy.

			VIDEO 85 OPTIMIZACIONES DEL BREADCRUMBS

Tal como tenemos la app si yo hago el logout no voy a cancelar la subscripción al this.router.events.subscribe( pues nunca la he cancelado,asinto).
Si un uusario hiciera logout y vuelve a entrar tendría dos Subscriptions,es por esto que tenemos que hacer una optimización en nuestro código,de echo ya hemos visto como:

public titleSub$: Subscription;

  constructor(private router: Router) {
    this.titleSub$ = this.getDataThroughRoute()
                     .subscribe(({ title }) => {
                       document.title = `AdminPro - ${title}`;
                       this.title = title;
                    }); 
  }
; 

Fijate que tuve que cortar la subscripcion,pues no puedo devolverla aún si uso una instancia de Subscription eso es una llamada a .subscribe,no a un método que ya llamó a .subscribe.

NOTA: tambien podía haber inyecado ActivatedRoute y acceder por otro lado a esa data,aunque hay que subscribirse igual y tiene downsides pues accedo a una snapshot.
Por último subimos todo a Github y hacemos el tag-release.
