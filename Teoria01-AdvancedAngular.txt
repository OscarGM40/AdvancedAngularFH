				SECCION 6 DIRECTIVAS DE COMUNICACION @INPUT Y @OUTPUT

Esta sección esta dedicada a los componentes y el envío de información entre ellos

1- Trabajaremos con Outputs, Inputs y ViewChild
2- Aprenderemos como utilizar atributos personalizados
3- Crearemos un componente re utilizable con una funcionalidad en especifico
4- Aprenderemos a tener referencias a elementos HTML
5- Tips de JavaScript puro: colocar el foco en elementos
6- Uso de gráficas como componentes personalizados

Al finalizar la sección, subiremos los cambios a GitHub, crearemos un release tag y también se encuentran unas tareas

					VIDEO 47 COMPONENTE PROGRESS BAR

Fijate que cuando me pase un diseñador un tema lo puedo abrir en el navegador y elegir un componente y copiarme el etiquetado html,tal como hacemos en este video
Tambien puedo seleccionar 'copiar dirección del link' tras poner el cursor en una etiqueta <link rel="stylesheet"> para ver los estilos de ese link.
En resumen me puedo copiar tanto el html como el css.

Con esto en mente copiamos la gráfica y el input group y sus estilos,es seguir el video

				VIDEO 48 CREAR COMPONENTE INCREMENTADOR

Para inferir a la template la propiedad progreso tenemos varias formas:
   style="height:10px;" 
   [style.width]="progreso+'%'"
Fijate como puedo usar [style.property]="propertyName" donde propertyName es una propiedad de la clase y la primera property una propiedad CSS.
Sin embargo,como es una sintaxis extraña mejor usamos un getter que me devuelva el valor normalizado.

  get getPorcentaje() { 
    return `${this.progreso}%`;
   }

Recuerda que para poder usar [(ngModel)]="progreso" hay que traer o el FormsModule o el ReactiveFormsModule en el modulo al que pertenezca ese control de formulario(en este caso un <input>).

					VIDEO 48 CREAR COMPONENTE INCREMENTADOR

Nuestra barra de progreso funciona bien,pero,¿y si quisiera varios?.Lo mejor es crear un componente y abstraer la lógica(imagina que necesito 10 gráficas).Siempre hay que separar la lógica para poder reutilizarla.Además,como pueden ser varios lo mejor es crear un modulo(o los que se necesiten).
Fijate como crear shared para los que sí que sé que va a haber varios y components para los que pudieran ser sólo únicos en la app también es una buena idea,asin.

Fijate que aunque también voy a llamar al FormsModule en este modulo,pero Angular es inteligente y sólo va a pedirlo una vez,la siguiente vez que encuentre que se pide a un módulo que él ya ha pedido lo tendrá en una caché.

						VIDEO 49 DIRECTIVA @INPUT 

Esta directiva se usa para recibit propiedades en el hijo que previamente han sido pasadas desde el padre en el selector de componente.Fijate que el padre siempre es  el que tenga el selector de componente.
Puedo usar el nombre que quiera como propiedad,o usar el mismo nombre que tendrá la propiedad,en el primer caso tendré que usar un argumento string en el @Input()

En el padre usaré valor,pero la propiedad de clase se llama progreso
<app-incrementador [valor]="15">
En el hijo,dado que renombré la propiedad tendré que usar el arg en la directiva
@Input('valor') progreso:number=50; <- si la hubiera llamado progreso en el padre no tengo que usar el arg,realmente es más legible no renombrar,salvo que tenga que hacerlo por alguna circusntancia.

*NOTA: Fijate que como va a enlazar con una clase(y aunque sea la de el hijo,no la suya) hay que usar [valor]="15".Da igual de quien sea la clase,hay que usar one-qay data-binding

				VIDEO 50 @OUTPUT & $EVENT EMISION DE EVENTOS HACIA EL PADRE

Si bien con @Input se recibe algo,luego la debe mandar alguién,es decir el padre,con @Output emitiremos hacia arriba un evento.
Usualmente las propiedades emitidas son de tipo EventEmitter<T>.Un EventEmitter debe saber qué tipo de información fluye a través de él,es por esto que es un genérico.

Dado que queremos emitir un número para el porcentaje de progreso ya sabemos el tipo también:
@Output() valorSalida:EventEmitter<number> = new EventEmitter(); <- hay  que inicializarlo para que no sea null,importante.

  cambiarValor(valor: number) {
    if (this.progreso >= 100 && valor > 0) {
      this.valorSalida.emit(100);
      return;
    }
    if (this.progreso <= 0 && valor < 0) {
      this.valorSalida.emit(0);
      return;
    }
    this.progreso = this.progreso + valor;
    this.valorSalida.emit(this.progreso);
  }

* IMPORTANTE: fijate que valorSalida:EventEmitter<T> es una función.Para recogerla en el selector,en la template del padre,hay que usar la sintaxis de evento:
<app-incrementador [valor]="15" (valorSalida)="cambioValorHijo($event)">
* No sólo hay que recibirla con paréntesis,sino que para acceder a su contenido hay que usar la propiedad pre-built $event que Angular provee

Realmente usar @Output va ligado a usar $event.Además,su tipo será el mismo que emitimos como genérico en el hijo(EventEmitter<number>) asi que es un number.Con todo esto en mente creo la función adecuada:
cambioValorHijo(valor:number){
  this.progresoUno=valor;

Sin embargo,dado que es un number y habría que crear otra función,con una lógica tan sencilla podemos utilizar la vista simplemente y evitar dos funciones.

 <app-incrementador 
              [valor]="progresoUno"
              (valorSalida)="progresoUno = $event"
              ></app-incrementador>
         </div>
      </div>
   </div>

   <div class="col-6">
      <div class="card">
         <div class="card-body">
            <app-incrementador
            [valor]="progresoDos"
            (valorSalida)="progresoDos = $event"
            ></app-incrementador>

Perfectamente puedo hacer "progresoDos = $event",ni que estuviera en HTML,tu.
NOTAS: puedo usar two-way data-binding cuando usar @Input y @Output pero la convención dicta que ambas directivas se llamen igual,con la @Output concatenando 'Change'.Ejemplo:

<app-incrementador [(progreso)]="progresoAzul"></app-incrementador>

export class IncrementadorComponent implements OnInit {
 
  @Input('progreso')
  progreso: number = 50;
 
  @Output('progresoChange')
  valueChange: EventEmitter<number> = new EventEmitter();
...
}
Por último esto es para componentes padre-hijo,con componentes hermanos se usa 
this.router.getCurrentnavigation().extras(NavigationExtras)

			VIDEO 51 [ngClass] COLOR DE LOS BOTONES DE FORMA CONDICIONAL

Queremos aplicar una clase según sea uno u otro incrementador.Usaremos la directiva [ngClass].Fijate que usar [] significa que quiero tomar el valor literal de esa propiedad en la clase.Lo que sea que es su valor,lo pones en el html.

 @Input() btnClass: string = 'btn btn-primary h-100';
NOTA:fijate que estoy mezclando una propiedad con @Input y no me da fallo,ni siquiera he recibido algo desde el padre y ya usé btnClass con su valor por defecto en la template.Muy interesante.

Realizar esto me dejará mandar desde el padre(o no mandar nada y actuar como una simple prop) una prop:string que sustituya al valor por defecto.

Claro que una la mandará y la otra no.Es la unión de @Input,su valor por defecto y ahora [ngClass].Realmente Angular es buenísimo,asin.

NOTA:fijate que acabo de decir que usar [] implica usar javascript y el valor literal:
[btnClass]="btn btn-info h-100" <- esto va a reventar,pues en JS no puedes usar guiones
También podría quitar las llaves para que lo interprete como un string,pero es una mala práctica porque Angular no sabe si quiero emitir o recibir.La solución es simplemente entrecomillar si hay guiones en cualquier literal al usar [] en Angular.

IMPORTANTE: realmente no hace falta que le pase las tres clases.Fijate como tratamos a la propiedad @Input como una simple propiedad de la clase.En el NgOnInit preparamos todo.

  ngOnInit(): void {
    this.btnClass = `btn ${this.btnClass} h-100`;
  }

					VIDEO 52 PULIENDO DETALLES

Al haber usado [(ngModel)] en un control de formulario,en ese mismo control tendré acceso a otro método llamado (ngModelChange).Lógicamente se dispara en cada cambio.LLamaremos a un método nuestro(es el onChange de react)

* Usar ngModel permite subscribirme a cada cambio
<input ... (ngModelChange)="onCustomChange($event)" [(ngModel)]="progreso">

Este método onCustomChange(valor:number)(es un number porque es un input type number) simplemente va a cambiar la propiedad de la clase 'progreso':

  onChange(valor: number) {
    if(valor >= 100) {
      this.progreso = 100;
    } else if (valor <= 0) {
      this.progreso = 0;
    } else {
      this.progreso = valor;
    }
    this.valorSalida.emit(this.progreso);
  }

Sabiendo que tengo en progreso siempre el valor tanto de los botones como ahora ddel input,y que ya no va a pasar de 0 o 100 podemos crear un estilo condicional con la directiva anterior [ngClass].Fijate que en el video anterior sólo la usamos para agregar una clase,pero no usamos condicionales en ella,sólo un literal.

 [ngClass]="{'is-invalid':progreso > 100 || progreso < 0 }"
Al usar condicionales me pedirá usar "{'class':condition}.Lógicamente,'class' va entrecomillado por los guiones y JS.

							VIDEO 54 GRAFICAS EN ANGULAR

De nuevo vamos a usar ng2-charts ya que se ven muy bien sus gráficas:
npm i ng2-charts chart.js <- fijate que me pide tanto la libreria base como la del framework y una esta en singular y la otra en plural.

Dado que truly sólo voy a usar esto dentro de las pages,puedo importarlo en ese módulo interno en vez de en el principal.claro que ya verás cuando no sea así,asinto. 

Fijate que voy a traer el ChartType de chart.js mientras que traeré Label,dataSet,... de ng2-charts.Es por esto que necesito las dos dependencias
import { ChartType } from 'chart.js';
import { MultiDataSet, Label } from 'ng2-charts';

  
   public doughnutChartLabels: Label[] = ['Download Sales', 'In-Store Sales', 'Mail-Order Sales'];
   public doughnutChartData: MultiDataSet = [
     [350, 450, 100],
   ];

Realmente no tiene nada crear la gráfica(fijate que le hemos pasado el type en la template para no usar otra propiedad de clase).

				VIDEO 55 TAREA @INPUT Y @OUTPUT

 De igual manera que abstraimos el componente incrementador queremos hacer lo mismo para la gráfica:
ng g c components/dona --skips-tests -is

Recuerda que lo que hay que hacer es no mandar la prop cuando quiero el valor por defecto!!
 <div class="col-6">
      <app-dona 
        [titulo]="'Ventas'" 
        [labels]="labels1"
        [data]="data1"
        [colors]="colors1" >
         >
      </app-dona>
   </div>
   
   <div class="col-6">
      <app-dona 
        [titulo]="" 
        >
     >

		SECCION 7 SERVICIOS,ROUTING BASICO,PERSISTENCIA DE LOS AJUSTES,TEMAS,...

Esta sección tiene varios temas importantes:

1- Crearemos un módulo para agrupar todos nuestros servicios
2- Aprenderemos a ejecutar scripts en archivos de JavaScript puros, en TypeScript
3- LocalStorage
4- Cambiar CSS de forma dinámica
5- Crear un componente para los ajustes del tema
6- Tips de JavaScript que se pueden usar en TypeScript
7- Preparar el servicio del Sidebar, el cual usaremos más adelante para crear nuestro menú dinámico en base a las respuestas de nuestro backend server

Al finalizar la sección creamos un release tag y hacemos un backup en git y github de todo el proyecto.
NOTA: fijate que interesante el servicio para el sidebar.

			VIDEO 62 DISEÑO INICIAL PAGE ACCOUNT-SETTINGS

Poner esto para el warning de ng2-charts y desargar el colores.txt del video 61.
<script src="https://cdn.jsdelivr.net/npm/chart.js@2.8.0"></script>
Creamos un nuevo componente,le creamos una ruta en pages.routing y copio el colores.txt suminstrado.

			VIDEO 63 CAMBIAR CSS PRINCIPAL DE MANERA DINÁMICA

 Si vamos al index veré que tengo el tema default-dark.css activado:
<link href="./assets/css/colors/default-dark.css" id="theme" rel="styles">
Sin embargo,si me voy a esa carpeta assets/css/colors veré 12 archivos .css,entre los que está default-dark.css,lógicamente.

¿Como hacemos para cambiar ese archivo dinámicamente?Para hacer cambios de este tipo FH recomienda usar Vanilla JS ya que esta etiqueta incluso se encuentra fuera de la app de Angular o de React(las apps de Angular y React son el <app-root> y el <div id="root> que están dentro del body)

No es nada complicado,ya que tenemos un atributo id(fijate que puedo poner un atributo id a un link en el header,algo que no habia visto hasta ahora.Simplemente buscaremos con el querySelector

Creo un evento (click)="changeTheme('default') || changeTheme('green') etc, que me pase la cadena de texto con el nombre del tema.Habrá que concatenarle la extensión.

changeTheme(theme:string){
   const url=`./assets/css/colors/${theme}.css`;
   const linkTheme = document.querySelector('#theme');
   linkTheme.setAttribute('href',url);

* Fijate lo fácil que es usando el método setAttribute('href', nuevaHref).También fijate que por mucho que este en Angular es como si estuviera en ese selector <app-root> y yo puedo hacer un document.querySelector de cualquier cosa del index.html desde ahi.
No sólo podría cambiar un <link href> también podría cambiar un <script src> y caponiendole un id y cambiando su atributo src dinámicamente:
<script src"..." id="script">
document.querySelector("#script").setAttribute("src",variable).Increible todo lo que desconoces aún,asinto.

Lógicamente perdemos el theme cuando refrescamos el navegador,pero podemos guardar la preferencia en el localStorage y cargarla.
IMPORTANTE: en cuanto cargue Pages.component ya debe haber un tema,no podemos ponerlo en el OnInit accountSettingsComponent

* El primer componente que muestre el dashboard debe cargar estos estilos(ya que el login y el register usan otro,pero si no ni siquiera podría esperar al DashboardComponent!)
export class PagesComponent implements OnInit {
  public year: number = new Date().getFullYear();
  public linkTheme = document.querySelector('#theme'); 
  constructor() { }

   ngOnInit(): void {

    const url =  localStorage.getItem('theme') || './assets/css/colors/purple-dark.css';
    this.linkTheme!.setAttribute('href', url);
  }
}
Realmente es muy sencillo cargar archivos css dinámicamente con setAttribute('href',nuevaUrl) y dando un id a la tag en el html <link id="theme">

			VIDEO 64 AGREGANDO CLASES CSS SIN USAR NGCLASS

Queremos agregar el check o visé en cada selector de tema,ya que nos falta hacerlo.Para hacer esto el provider del tema nos especifica que se hace agregando la clase 'working'.
Hay varias formas de hacer esto,una sería con ngClass pero quedaría mucho código.

Veamos como hacerlo de otra forma,dado que todas las <anchor> tienen la clase selector + theme + working o no hacemos un querySelectorAll.
Ojo,que esto devolvia un NodeListOf<Element,podemos verlo como una lista de elementos HTML esa lista de nodos.

checkCurrentTheme(){
  const links = document.querySelectorAll('.selector')
  links.forEach( elem => {
    elem.classList.remove('working');
    const btnTheme = elem.getAttribute('data-theme');
    const btnThemeUrl = `./assets/css/colors/${btnTheme}.css`;
    const currentTheme = this.linkTheme.getAttribute('href');
   * si coinciden tengo que agregarle la clase working
   if(btnThemeUrl === currentTheme) {
    elem.classList.add('working') }

* Lo primero es eliminar esa clase ya que la quiero poner yo programáticamente.
Despues,dado que todas las anchor tienen ese atributo custom data-theme,puedo acceder simplemnte con getAttribute('data-theme').Fijate que ya lo trae,pero podría crearlo yo.
NOTA: HTML5 CUSTOM DATA ATTRIBUTES => siempre debe tener minimo un caracter y precedido por 'data-',no puede tener mayúsculas(data-age,data-spacing,data-xxx).
Su intención es poder almacenar datos pertenecientes a la página o aplicación,par los cuales no debería haber una mejor forma para hacerlo.(simplemente almacenan variables,muy intesante pues).

Aun me faltará llamar a this.checkCurrentTheme en el changeTheme():

changeTheme(theme: string) {
    const url = `assets/css/colors/${theme}.css`;
    this.linkTheme!.setAttribute('href', url);
    localStorage.setItem('theme', url);
    this.checkCurrentTheme();
  }

IMPORTANTE: fijate como FH decide llamar a los document.querySelector en el ngOnInit.El NgOnInit se va a disparar cuando ya está inicializado el componente,es decir,que ya tendré el HTML,asi que ningun querySelector va a fallar.

* No dejarla como any,por algo usamos TS
public links!:NodeListOf<Element>;

ngOnInit():void {
  this.links.querySelectorAll('.selector');
} 
Es una idea perfecta

						VIDEO 65 SERVICIO SETTINGS

¿Que pasaría si también quisiara ver el tema en otra parte de la aplicación?O que necesitara saber ese tema en otra parte,etc? Hay muchos motivos por los que podría querer saber el tema que estoy usando,asi que lo mejor sería centralizar la lógica en un servicio.
Inclusive no tiene porque ser el tema,pueden ser un grupo de ajustes o las credenciales.Lo ideal es centralizar siempre la lógica con un servicio.

Dado que no vamos a tener muchos servicios podemos usar una carpeta para todos,pero lo ideal sería ir creando servicios por cada módulo(auth.service.ts,shared.service.ts).

NOTA:fijate que cuando la aplicación de Angular se crea ya existe la etiqueta <link id="theme" rel="stylesheet"> asi que no tengo que meter el document.querySelector('#theme') en el ngOnInit como si es el caso de los enlaces del componente,que hay que esperar que se construyan.
También si los creara yo por código tengo que usar el ciclo de vida de Angular.

¿Y porqué va esto en el constructor del Service?Por lo mismo,cuando arranque la app se llamará al servicio porque lo pide el PagesComponent(lo inyecta).Y en cuanto se cree esa instancia se llamará al constructor del servicio,ejecutando su lógica:

export class SettingsService {

  private linkTheme = document.querySelector('#theme'); 

  constructor() {
    const url =  localStorage.getItem('theme') || './assets/css/colors/purple-dark.css';
    this.linkTheme!.setAttribute('href', url);
   } }
Realmente no hemos cambiado nada con esta lógica y ya centralizé todo.Amazing.

Veamos que puedo pasar ahora al servicio desde el AccountSettingsComponent:

* Fijate que estos enlaces,si llevo esta lógica al servicio,no van a existir en el DOM cuando se carge el servicio,no obstante vamos a saltar al DOM cada vez que se ejecute el método del servicio,sin embargo,como sólo son 10 enlaces apenas es costoso y lo puedo sacar al servicio perfectamente  

checkCurrentTheme() {
    const links: NodeListOf<Element>=document.querySelectorAll('.selector');
    links.forEach(elem => {
      elem.classList.remove('working');
      const bg = elem.getAttribute('data-theme');
      const bgUrl = `assets/css/colors/${bg}.css`;
      const currentTheme = localStorage.getItem('theme');
      if (bgUrl === currentTheme) {
        elem.classList.add('working');
      }
    })
  }
S
Todo esto se hace para tener el componente lo más limpio posible,fijate como queda,asin:

export class AccountSettingsComponent implements OnInit {

  changeTheme(theme: string) {
    this.settingsService.changeTheme(theme);
  }

  constructor(private settingsService: SettingsService) { }
  
  ngOnInit(): void {
    this.settingsService.checkCurrentTheme();    
  }
    
Si quisiera incluso podría mandar los enlaces aqui,en el OnInit del AccountSettingsComponent(asi no salto al DOM):
 ngOnInit(): void {
    this.settingsService.checkCurrentTheme(enlaces);    
  }
Es decir que los declararía y buscaría en el componente y el servicio los recibe como argumento,pero como son apenas 10 <anchor> no nos importa el coste que tendrá esa operación.
Fijate que esto es importante,asinto,cuando y quien salta al DOM.

			VIDEO 6 ROUTERLINK -MOVER A UNA RUTA EN PARTICULAR

Ya podría crear el enlace a dashboard/account-settings pues ya está terminado el componente.Para ello voy al sidebar.component.html.
IMPORTANTE:fijate que puedo usar varias alternativas para pasar la url:
1- <a routerLink="/dashboard/account-settings"> <- poner la ruta absoluta
2- <a routerLink="account-settings"> <- ruta relativa,como ya estoy en /dashboard va a concatenarse /account-settings,haciendo /dashboard/account-settings.Claro que las relativas tienen peligro asin,pero no en un sidebar como este.

3- <a [routerLink]="['dashboard/account-settings']">

* Una de las diferencias radica en que haciéndolo así  [routerLink]="['/dashboard/account-settings']" vas a poder incluir algún tipo de condicional, por ejemplo: [routerLink]="url_settings ? '/dashboard/account-settings' : '/dashboard/home'"
en cambio de esta forma  routerLink="/dashboard/account-settings"

Fijate que en cuando necesite condiciones tengo que hacer data-binding en vez de pasarlo como un string.

			VIDEO 67 SERVICIO PARA CONTROLAR EL MENU LATERAL-SIDEBAR

Queremos construir el menú de manera dinámica,será un backend el que mande las opciones de menú.Lo vamos a hacer en un servicio porque en el logout purgaremos esas opciones y en el login las cargaremos,ole.

EN el servicio creo una propiedad con el menu,claro que más tarde cargará esto de un backend:

  menu: any[] = [
    { 
      titulo:'Dashboard!!',
      icono:'mdi mdi-gauge', 
      submenu:[
        {titulo:'Main', url:'/'},
        {titulo:'ProgressBar', url:'/progress'},
        {titulo:'GraficaDona', url:'/grafica-dona'},
      ]
    }
  ]

En el sidebar la guardo en una propiedad para poder llevarla a la template e iterrar:

 menuItems: any[] ;

  constructor(private sidebarService: SidebarService) { 
    this.menuItems = sidebarService.menu;
  }


Itero sobre la template,asignando los valores. Fijate que tremendamente interesante es esto,y lo fácil que es:

    <li *ngFor="let item of menuItems">
          <i class="mdi mdi-gauge"></i>
          <span class="hide-menu">{{item.titulo}}
          <span  class="label label-rouded label-themecolor pull-right">{{item.submenu.length}}</span></span>
         
          <li *ngFor="let subitem of item.submenu">
             <a [routerLink]="subitem.url">{{subitem.titulo}}</a> 
          </li>
    </li>

Fijate como puedo anidar bucles en la template si lo necesito.Si el dia de mañana quiero agregar otras rutas+subrutas solo tengo que ir al servicio y agregarlas.

	VIDEO 68 USO DE SCRIPTS DE ARCHIVOS IMPORTADOS EN EL INDEX.HTML EN TYPESCRIPT

NOTA: recuerda que routerLink="login" concatena login a la ruta actual,para ir al login en esta app hay que usar "/login"(absoluta)

Recuerda que Angular inyecta el event.preventDefault() a los formularios en cuanto use el FormsModule o el ReactiveFormsModule(cualquiera de los dos,en cuanto los importe al módulo mis formularios dejarán de hacer refresh).
	 
Con esto en mente vamos simplemente a redireccionar al home al hacer login(ya lo crearemos):
 constructor(private router: Router ) { }

  ngOnInit(): void {
  }

  login(){ 
    this.router.navigateByUrl('/');
  }
IMPORTANTE: fijate que esto destruye todo el componente,y el dashboard no carga bien,esto es porque hay un script al final del body que inicializa a los demás y lo hemos destruido(pues se destruyó el index.html)

La etiqueta <script> es esta:
<!--Custom JavaScript -->
  <script src="./assets/js/custom.min.js"></script>

De alguna manera tengo que volver a cargar ese script cuando haga la redirección el router de Angular en el login.
Dado que es JQuery voy a ese archivo y meto todo en una función que voy a disparar yo:
const customInitFunctions = () => {
    $(function() {
        "use strict";
        $(function() {
          ...

customInitFunctions().

Bien,está claro que hay que llamar a esta función que está en un <script>.O Bien en el app.component.ts o en el pages.component.ts también nos vale.

declare function customInitFunctions():any;

@Component({
  selector: 'app-pages',
  templateUrl: './pages.component.html',
})
export class PagesComponent implements OnInit {
   ngOnInit(): void {
    customInitFunctions();
  }
La función esta declarada de manera global,pero TS se va a quejar,lo que hay que hacer es usar declare function functionName():any; y con esto puedo llamar a cualquier función declarada global(en el primer scope de cualquier archivo,que no esté anidada:

En cualquier archivo del proyecto:
const xxx = () => {} <- está lo más externa posible al archivo,esto es una función global,el resto de la app tiene visión sobre ella.

En resumen,puedo acceder desde Angular a código de afuera de él(recuerda que Angular es solo la tag <app-root> en un index.html.Pues puedo acceder a código de ese index.html,cualquier <script>,etc...
Incluso podriamos haber usado argumentos.

				VIDEO 69-70 SUBIR CAMBIOS A GITHUB

Subo los cambios a Github,creo una tag y le hago el release.Recuerda especificar qué cambios hice.

						SECCION 08 OBSERVABLES Y PROMESAS

Si bien son bastante similares,las promesas son muy difíciles de cancelar,cuando  se lanza es casi imposible cancelarla,sin embargo un Observable me permite más control sobre lo que estoy haciendo.
También pueden estar emitiendo un flujo continuo de información,la Promesa sólo emite información una vez(importante)

Esta sección tiene por objetivo principal, trabajar con observables y promesas:

1- Tendremos una introducción ilustrativa para explicar estos dos temas
2- Trabajaremos con promesas y funciones que retornan promesas
3- Aprenderemos a crear un observable manualmente
4- Trabajaremos con operadores de los observables como:
5- Retry
6- Map
7- Filter
8- Next
9- Funciones que retornan observables

Usaremos el conocimiento aprendido para crear un componente de seguimiento de la página actual
Usaremos observables para leer parámetros de configuración de las rutas que son diferentes a los parámetros de las rutas por url
Cambiaremos los metatags dependiendo de la página donde nos encontremos
Cambiar el titulo de la página actual
Al finalizar, realizamos el respectivo backup en GitHub, junto a su release TAG.

			VIDEO 73 INTRODUCCIÓN A PROMESAS Y OBSERVABLES


